import type { EntityBase } from './entity-base';
import { DeSerializers } from './de-serializers';
import { EntityApi } from './entity-api';
/**
 * Union type of `null` and `undefined`.
 */
export type NullishTypes = null | undefined;
/**
 * Exclude all nullish types from the given type so NonNullishType<TypeA | TypeB | undefined> is TypeA | TypeB.
 */
export type NonNullishType<T> = Exclude<T, NullishTypes>;
/**
 * Omits all nullish properties as well as all properties of the {@link EntityBase} from a given type.
 */
export type PureEntityType<T> = Omit<NonNullishType<T>, keyof EntityBase>;
/**
 * Type to describe possible inputs for `.fromJson`.
 * This is based on the JSON type of an entity and allows all properties to be optional recursively.
 * It also allows setting unknown properties, which will be treated as custom fields.
 * @typeParam JsonT - JSON type of the entity.
 */
export type FromJsonType<JsonT> = {
    [key: string]: any;
} & {
    [P in keyof PureEntityType<JsonT>]?: PureEntityType<JsonT>[P] extends (infer U)[] | null | undefined ? U extends Record<string, any> ? FromJsonType<U>[] : PureEntityType<JsonT>[P] : PureEntityType<JsonT>[P] extends Record<string, any> | null | undefined ? FromJsonType<PureEntityType<JsonT>[P]> | null | undefined : PureEntityType<JsonT>[P];
};
/**
 * Contains the methods to build an entity.
 */
export declare class EntityBuilder<EntityT extends EntityBase, DeSerializersT extends DeSerializers> {
    readonly _entityApi: EntityApi<EntityT, DeSerializersT>;
    protected _entity: EntityT;
    constructor(_entityApi: EntityApi<EntityT, DeSerializersT>);
    /**
     * Sets the custom fields for the entity.
     * @param customFields - The custom fields you want to add.
     * @returns The entity builder itself for method chaining.
     */
    withCustomFields(customFields: Record<string, any>): this;
    /**
     * Builds the entity.
     * @returns The entity.
     */
    build(): EntityT;
    /**
     * Builds an entity from JSON representation.
     * If you have obtained the JSON object as a request payload use the {@link entityDeserializer} methods.
     * Note that fields not mappable to a field in the target entity are silently ignored.
     * @param json - Representation of the entity in JSON format.
     * @returns EntityBase constructed from JSON representation.
     */
    fromJson(json: FromJsonType<EntityT>): EntityT;
    private filterCustomFields;
}
