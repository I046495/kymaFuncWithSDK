"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEdmType = exports.getEntityConstructor = exports.ComplexTypeField = void 0;
const edm_types_1 = require("../edm-types");
const field_1 = require("./field");
/**
 * Represents a complex type property of an entity or a complex type.
 *
 * `ComplexTypeField`s are used as static properties of entities and are generated from the metadata, i.e. for each property of
 * an OData entity, that has a complex type, there exists one static instance of `ComplexTypeField` (or rather one of its subclasses) in the corresponding generated class file.
 * `ComplexTypeField`s are used to represent the domain of complex or custom structures that can be used in select, filter and order by functions.
 * For example, when constructing a query on the TimeSheetEntry entity, an instance of `ComplexTypeField<TimeSheetEntry>`
 * can be supplied as argument to the select function, e.g. `TimeSheetEntry.TIME_SHEET_DATA_FIELDS`.
 * Moreover, classes implementing this abstract class will provide property fields, that can be used for filtering and ordering.
 *
 * See also: {@link Selectable}.
 * @typeParam EntityT - Type of the entity the field belongs to.
 * @typeParam DeSerializersT - Type of the (de-)serializers.
 * @typeParam ComplexT - Type of complex type represented by this field.
 * @typeParam NullableT - Boolean type that represents whether the field is nullable.
 * @typeParam SelectableT - Boolean type that represents whether the field is selectable.
 */
class ComplexTypeField extends field_1.Field {
    /**
     * Creates an instance of ComplexTypeField.
     * @param fieldName - Actual name of the field as used in the OData request.
     * @param fieldOf - Either the parent entity constructor of the parent complex type this field belongs to.
     * @param deSerializers - (De-)serializers used for transformation.
     * @param _complexType - The complex type of the complex type property represented by this.
     * @param fieldOptions - Optional settings for this field.
     */
    constructor(fieldName, fieldOf, deSerializers, _complexType, fieldOptions) {
        super(fieldName, getEntityConstructor(fieldOf), fieldOptions);
        this.fieldOf = fieldOf;
        this.deSerializers = deSerializers;
        this._complexType = _complexType;
    }
    /**
     * Gets the path to the complex type property represented by this.
     * @returns The path to the complex type property.
     */
    fieldPath() {
        return this.fieldOf instanceof ComplexTypeField
            ? `${this.fieldOf.fieldPath()}/${this._fieldName}`
            : this._fieldName;
    }
}
exports.ComplexTypeField = ComplexTypeField;
/**
 * Convenience method to get the entity constructor of the parent of a complex type.
 * @param fieldOf - Either an entity constructor or another complex type field.
 * @returns The constructor of the transitive parent entity;
 * @internal
 */
function getEntityConstructor(fieldOf) {
    return fieldOf instanceof ComplexTypeField
        ? fieldOf._entityConstructor
        : fieldOf;
}
exports.getEntityConstructor = getEntityConstructor;
/**
 * Convenience method to get the {@link EdmTypeShared} from the overloaded constructor.
 * The two scenarios are:
 * - `complexTypeNameOrEdmType` is of type `EdmTypeShared` and `edmTypeOrUndefined` is `undefined`
 * - `complexTypeNameOrEdmType` is of type `string` and `edmTypeOrUndefined` is of type `EdmTypeShared`
 * @param complexTypeNameOrEdmType - Either the name of the complex type or the EDM type.
 * @param edmTypeOrUndefined - Either the EDM type or `undefined`.
 * @returns The EDM type resolved for the two arguments.
 * @internal
 */
function getEdmType(complexTypeNameOrEdmType, edmTypeOrUndefined) {
    if (edmTypeOrUndefined) {
        if (typeof complexTypeNameOrEdmType === 'string' &&
            !(0, edm_types_1.isEdmType)(complexTypeNameOrEdmType) &&
            (0, edm_types_1.isEdmType)(edmTypeOrUndefined)) {
            return edmTypeOrUndefined;
        }
    }
    else if ((0, edm_types_1.isEdmType)(complexTypeNameOrEdmType)) {
        return complexTypeNameOrEdmType;
    }
    throw new Error(`Failed to get EDM type based on '${complexTypeNameOrEdmType}' and '${edmTypeOrUndefined}'.`);
}
exports.getEdmType = getEdmType;
//# sourceMappingURL=complex-type-field.js.map