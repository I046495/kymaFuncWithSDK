"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterFunctions = exports.isOf = exports.year = exports.second = exports.month = exports.minute = exports.hour = exports.day = exports.ceiling = exports.floor = exports.round = exports.concat = exports.trim = exports.toUpper = exports.toLower = exports.substring = exports.indexOf = exports.length = exports.startsWith = exports.endsWith = void 0;
const filter_function_1 = require("./filter-function");
/* String Functions */
/**
 * @internal
 * Build a filter function to test whether a string ends with another. Evaluates to boolean.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 * @param suffix - The suffix to test for. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function endsWith(str, suffix) {
    return (0, filter_function_1.filterFunction)('endswith', 'boolean', str, suffix);
}
exports.endsWith = endsWith;
/**
 * @internal
 * Build a filter function to test whether a string starts with another. Evaluates to boolean.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 * @param prefix - The prefix to test for. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function startsWith(str, prefix) {
    return (0, filter_function_1.filterFunction)('startswith', 'boolean', str, prefix);
}
exports.startsWith = startsWith;
/**
 * @internal
 * Build a filter function to get the length of a string. Evaluates to int.
 * @param str - The string to compute the length for. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function length(str) {
    return (0, filter_function_1.filterFunction)('length', 'int', str);
}
exports.length = length;
/**
 * @internal
 * Build a filter function to get the start index of a substring. Evaluates to int.
 * @param str - The string to get the index from. This can either be a string, a reference to a field or another filter function.
 * @param substr - The substring to get the index for. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function indexOf(str, substr) {
    return (0, filter_function_1.filterFunction)('indexof', 'int', str, substr);
}
exports.indexOf = indexOf;
/**
 * @internal
 * Build a filter function to get a substring starting from a designated position. Evaluates to string.
 * @param str - The string to get a substring from. This can either be a string, a reference to a field or another filter function.
 * @param pos - The starting position of the substring. This can be either a number, a reference to a field or another filter function.
 * @param len - The length of the substring. This can be either a number, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function substring(str, pos, len) {
    return typeof len === 'undefined'
        ? (0, filter_function_1.filterFunction)('substring', 'string', str, pos)
        : (0, filter_function_1.filterFunction)('substring', 'string', str, pos, len);
}
exports.substring = substring;
/**
 * @internal
 * Build a filter function to transform a string to lower case. Evaluates to string.
 * @param str - The string to transform. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function toLower(str) {
    return (0, filter_function_1.filterFunction)('tolower', 'string', str);
}
exports.toLower = toLower;
/**
 * @internal
 * Build a filter function to transform a string to upper case. Evaluates to string.
 * @param str - The string to transform. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function toUpper(str) {
    return (0, filter_function_1.filterFunction)('toupper', 'string', str);
}
exports.toUpper = toUpper;
/**
 * @internal
 * Build a filter function to trim whitespace from a string. Evaluates to string.
 * @param str - The string to trim whitespace from. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function trim(str) {
    return (0, filter_function_1.filterFunction)('trim', 'string', str);
}
exports.trim = trim;
/**
 * @internal
 * Build a filter function to concatenate two strings. Evaluates to string.
 * @param str1 - The first string to concatenate. This can either be a string, a reference to a field or another filter function.
 * @param str2 - The second string to concatenate. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function
 */
function concat(str1, str2) {
    return (0, filter_function_1.filterFunction)('concat', 'string', str1, str2);
}
exports.concat = concat;
/* Math Functions */
/**
 * Build a filter function to round a number. Evaluates to double or decimal, defaults to double.
 * @param num - The number to round. This can either be a number, a reference to a field or another filter function.
 * @param returnType - The return type to use.
 * @returns The newly created filter function
 * @internal
 */
function round(num, returnType = 'double') {
    return (0, filter_function_1.filterFunction)('round', returnType, num);
}
exports.round = round;
/**
 * Build a filter function to floor a number. Evaluates to double or decimal, defaults to double.
 * @param num - The number to floor. This can either be a number, a reference to a field or another filter function.
 * @param returnType - The return type to use.
 * @returns The newly created filter function
 * @internal
 */
function floor(num, returnType = 'double') {
    return (0, filter_function_1.filterFunction)('floor', returnType, num);
}
exports.floor = floor;
/**
 * Build a filter function to ceil a number. Evaluates to double or decimal, defaults to double.
 * @param num - The number to ceil. This can either be a number, a reference to a field or another filter function.
 * @param returnType - The return type to use.
 * @returns The newly created filter function
 * @internal
 */
function ceiling(num, returnType = 'double') {
    return (0, filter_function_1.filterFunction)('ceiling', returnType, num);
}
exports.ceiling = ceiling;
/* Date Functions */
/**
 * Build a filter function to get the day of a date. Evaluates to int.
 * @param date - The date to get the day for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function day(date) {
    return (0, filter_function_1.filterFunction)('day', 'int', date);
}
exports.day = day;
/**
 * Build a filter function to get the hour of a date. Evaluates to int.
 * @param date - The date to get the hour for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function hour(date) {
    return (0, filter_function_1.filterFunction)('hour', 'int', date);
}
exports.hour = hour;
/**
 * Build a filter function to get the minute of a date. Evaluates to int.
 * @param date - The date to get the minute for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function minute(date) {
    return (0, filter_function_1.filterFunction)('minute', 'int', date);
}
exports.minute = minute;
/**
 * Build a filter function to get the month of a date. Evaluates to int.
 * @param date - The date to get the month for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function month(date) {
    return (0, filter_function_1.filterFunction)('month', 'int', date);
}
exports.month = month;
/**
 * Build a filter function to get the second of a date. Evaluates to int.
 * @param date - The date to get the second for. This can either be a date (moment.Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function second(date) {
    return (0, filter_function_1.filterFunction)('second', 'int', date);
}
exports.second = second;
/**
 * Build a filter function to get the year of a date. Evaluates to int.
 * @param date - The date to get the year for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function
 * @internal
 */
function year(date) {
    return (0, filter_function_1.filterFunction)('year', 'int', date);
}
exports.year = year;
/**
 * @param expressionOrType - expressionOrType
 * @param type - type
 * @returns returns if the type matches
 * @internal
 */
function isOf(expressionOrType, type) {
    return type
        ? (0, filter_function_1.filterFunction)('isof', 'boolean', expressionOrType, type)
        : (0, filter_function_1.filterFunction)('isof', 'boolean', expressionOrType);
}
exports.isOf = isOf;
/**
 * Filter functions common to both OData v2 and OData v4. See below for version specific filter functions.
 * Filter functions are used to create more complex filtering expressions, e.g. when filtering by the first letter of a property:
 * ```
 *  .filter(startsWith(BusinessPartner.FIRST_NAME, 'A').equals(true))
 * ```
 * @internal
 * @param deSerializers - DeSerializer used in the filter
 * @returns filter functions
 */
function filterFunctions(
// eslint-disable-next-line
deSerializers) {
    return {
        endsWith,
        startsWith,
        length,
        indexOf,
        substring,
        toLower,
        toUpper,
        trim,
        concat,
        round,
        floor,
        ceiling,
        day,
        hour,
        minute,
        month,
        second,
        year,
        isOf
    };
}
exports.filterFunctions = filterFunctions;
//# sourceMappingURL=filter-functions.js.map