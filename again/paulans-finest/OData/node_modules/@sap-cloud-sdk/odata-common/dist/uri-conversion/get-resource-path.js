"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createGetResourcePathForKeys = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const logger = (0, util_1.createLogger)({
    package: 'odata-common',
    messageContext: 'get-resource-path'
});
/**
 * Creates a getResourcePathForKeys function using the OData v2 or OData v4 URI converter.
 * The concrete instances for v2 or v4 are initiated in odata/v2/uri-conversion/odata-uri.ts and odata/v4/uri-conversion/odata-uri.ts.
 * @param uriConverter - Uri converter for v2 or v4.
 * @returns The filter getter. See {@link GetFilter}
 * @internal
 */
function createGetResourcePathForKeys(uriConverter) {
    /**
     * @internal
     * Get the resource path of an entity specified by key-value pairs.
     * @typeParam EntityT - Type of the entity to get the resource path for.
     * @param keys - Key-value pairs where the key is the name of a key property of the given entity and the value is the respective value.
     * @param entityApi - Entity API of the entity to get the resource path for.
     * @returns The path to the resource.
     */
    function getResourcePathForKeys(keys = {}, { entityConstructor, schema }) {
        keys = filterNonKeyProperties(keys, entityConstructor);
        validateKeys(keys, entityConstructor);
        if (Object.keys(keys).length) {
            const byKey = Object.entries(keys)
                .map(([key, value]) => keyToOData(key, value, schema))
                .join(',');
            return `${entityConstructor._entityName}(${byKey})`;
        }
        return entityConstructor._entityName;
    }
    function getMissingKeys(keys, entityConstructor) {
        const givenKeys = Object.keys(keys);
        return entityConstructor._keys
            .map(key => key)
            .filter(fieldName => !givenKeys.includes(fieldName));
    }
    function getInvalidKeys(keys, entityConstructor) {
        return Object.keys(keys).filter(key => !entityConstructor._keys.includes(key));
    }
    function getNullishKeys(keys) {
        return Object.entries(keys)
            .filter(([, value]) => (0, util_1.isNullish)(value))
            .map(([key]) => key);
    }
    function filterNonKeyProperties(keys, entityConstructor) {
        const invalidKeys = getInvalidKeys(keys, entityConstructor);
        if (invalidKeys.length) {
            logger.warn(`There are too many key properties. Ignoring the following keys: ${invalidKeys.join(', ')}`);
            return Object.entries(keys)
                .filter(([key]) => !invalidKeys.includes(key))
                .reduce((validKeys, [key, value]) => ({ ...validKeys, [key]: value }), {});
        }
        return keys;
    }
    function keyToOData(key, value, schema) {
        const edmType = schema[(0, util_1.upperCaseSnakeCase)(key)].edmType;
        return `${key}=${encodeURIComponent(uriConverter(value, edmType))}`;
    }
    function validateKeys(keys, entityConstructor) {
        const missingKeys = getMissingKeys(keys, entityConstructor);
        if (missingKeys.length) {
            throw new Error(`Cannot get resource path for entity ${entityConstructor._entityName}. The following keys are missing: ${missingKeys.join(', ')}`);
        }
        const nullishKeys = getNullishKeys(keys);
        if (nullishKeys.length) {
            throw new Error(`Cannot get resource path for entity ${entityConstructor._entityName}. The following keys have nullish values, but are not nullable: ${nullishKeys.join(', ')}`);
        }
    }
    return { getResourcePathForKeys };
}
exports.createGetResourcePathForKeys = createGetResourcePathForKeys;
//# sourceMappingURL=get-resource-path.js.map