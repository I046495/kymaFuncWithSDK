"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.searchServiceBindingForDestination = exports.destinationForServiceBinding = exports.getDestinationFromServiceBinding = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const jwt_1 = require("../jwt");
const environment_accessor_1 = require("../environment-accessor");
const http_proxy_util_1 = require("./http-proxy-util");
const destination_service_types_1 = require("./destination-service-types");
const destination_cache_1 = require("./destination-cache");
const service_binding_to_destination_1 = require("./service-binding-to-destination");
const forward_auth_token_1 = require("./forward-auth-token");
const logger = (0, util_1.createLogger)({
    package: 'connectivity',
    messageContext: 'destination-accessor-vcap'
});
/**
 * Tries to build a destination from a service binding with the given name.
 * Throws an error if no services are bound at all, no service with the given name can be found, or the service type is not supported.
 * The last error can be circumvent by using the second parameter to provide a custom function that transforms a service binding to a destination.
 * @param options - Options to customize the behavior of this function.
 * @returns A destination.
 */
async function getDestinationFromServiceBinding(options) {
    const decodedJwt = options.iss
        ? { iss: options.iss }
        : options.jwt
            ? (0, jwt_1.decodeJwt)(options.jwt)
            : undefined;
    const retrievalOptions = { ...options, jwt: decodedJwt };
    let destination;
    if (options.useCache) {
        destination = await destination_cache_1.destinationCache.retrieveDestinationFromCache((0, jwt_1.decodeOrMakeJwt)(retrievalOptions.jwt), retrievalOptions.destinationName, 'tenant');
    }
    if (!destination) {
        destination = await retrieveDestinationWithoutCache(retrievalOptions);
        if (options.useCache) {
            // As the grant type is clientCredential, isolation strategy is 'tenant'.
            await destination_cache_1.destinationCache.cacheRetrievedDestination((0, jwt_1.decodeOrMakeJwt)(options.jwt), destination, 'tenant');
        }
    }
    const destWithProxy = destination &&
        (0, destination_service_types_1.isHttpDestination)(destination) &&
        ['internet', 'private-link'].includes((0, http_proxy_util_1.proxyStrategy)(destination))
        ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
    if (destWithProxy) {
        (0, forward_auth_token_1.setForwardedAuthTokenIfNeeded)(destWithProxy, options.jwt);
    }
    return destWithProxy;
}
exports.getDestinationFromServiceBinding = getDestinationFromServiceBinding;
async function retrieveDestinationWithoutCache({ useCache, jwt, destinationName, serviceBindingTransformFn }) {
    const service = (0, environment_accessor_1.getServiceBindingByInstanceName)(destinationName);
    const destination = await (serviceBindingTransformFn || transform)(service, {
        useCache,
        jwt
    });
    return { name: destinationName, ...destination };
}
/**
 * Tries to build a destination from a service binding with the given name.
 * Throws an error if no services are bound at all, no service with the given name can be found, or the service type is not supported.
 * The last error can be circumvent by using the second parameter to provide a custom function that transforms a service binding to a destination.
 * @param serviceInstanceName - The name of the service.
 * @param options - Options to customize the behavior of this function.
 * @returns A destination.
 * @deprecated Since v3.4.0. Use {@link getDestinationFromServiceBinding} instead.
 */
async function destinationForServiceBinding(serviceInstanceName, options = {}) {
    if (options.useCache) {
        const destinationFromCache = await destination_cache_1.destinationCache.retrieveDestinationFromCache((0, jwt_1.decodeOrMakeJwt)(options.jwt), serviceInstanceName, 'tenant');
        if (destinationFromCache) {
            return destinationFromCache;
        }
    }
    const optionsForTransformation = {
        useCache: options.useCache,
        jwt: options.jwt
    };
    const selected = (0, environment_accessor_1.getServiceBindingByInstanceName)(serviceInstanceName);
    const transformFn = options.serviceBindingTransformFn || transform;
    const destination = await transformFn(selected, optionsForTransformation);
    const destWithProxy = destination &&
        (0, destination_service_types_1.isHttpDestination)(destination) &&
        ['internet', 'private-link'].includes((0, http_proxy_util_1.proxyStrategy)(destination))
        ? (0, http_proxy_util_1.addProxyConfigurationInternet)(destination)
        : destination;
    if (options.useCache) {
        // As the grant type is clientCredential, isolation strategy is 'tenant'.
        await destination_cache_1.destinationCache.cacheRetrievedDestination((0, jwt_1.decodeOrMakeJwt)(options.jwt), destWithProxy, 'tenant');
    }
    return destWithProxy;
}
exports.destinationForServiceBinding = destinationForServiceBinding;
async function transform(service, options) {
    if (!service_binding_to_destination_1.serviceToDestinationTransformers[service.label]) {
        throw serviceTypeNotSupportedError(service);
    }
    return service_binding_to_destination_1.serviceToDestinationTransformers[service.label](service, options);
}
function serviceTypeNotSupportedError(service) {
    return Error(`The service "${service.name}" is of type "${service.label}" which is not supported! Consider providing your own transformation function when calling \`getDestinationFromServiceBinding()\`, like this:
  destinationServiceForBinding(yourServiceName, { serviceBindingToDestination: yourTransformationFunction });`);
}
/**
 * @internal
 */
async function searchServiceBindingForDestination(options) {
    logger.debug('Attempting to retrieve destination from service binding.');
    try {
        const destination = await getDestinationFromServiceBinding(options);
        logger.info('Successfully retrieved destination from service binding.');
        return destination;
    }
    catch (error) {
        logger.debug(`Could not retrieve destination from service binding. If you are not using SAP Extension Factory, this information probably does not concern you. ${error.message}`);
    }
    return null;
}
exports.searchServiceBindingForDestination = searchServiceBindingForDestination;
//# sourceMappingURL=destination-from-vcap.js.map