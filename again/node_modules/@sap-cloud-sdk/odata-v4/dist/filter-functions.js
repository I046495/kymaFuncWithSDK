"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.filterFunctions = exports.hasSubsequence = exports.hasSubset = exports.now = exports.minDateTime = exports.maxDateTime = exports.totalOffsetMinutes = exports.fractionalSeconds = exports.matchesPattern = exports.contains = void 0;
const internal_1 = require("@sap-cloud-sdk/odata-common/internal");
const filter_function_1 = require("./filter-function");
const de_serializers_1 = require("./de-serializers");
/* String Functions */
/**
 * Build a filter function to test whether a string is a substring of the other. Evaluates to boolean.
 * @param substr - The substring to test for. This can either be a string, a reference to a field or another filter function.
 * @param str - The string to test. This can either be a string, a reference to a field or another filter function.
 * @returns The newly created filter function.
 */
function contains(substr, str) {
    return (0, filter_function_1.filterFunction)('contains', 'boolean', substr, str);
}
exports.contains = contains;
/**
 * Build a filter function to test whether a string matches a pattern. Evaluates to boolean.
 * @param str - The string to get the index from. This can either be a string, a reference to a field or another filter function.
 * @param regex - The pattern to test against. This should be a regular expression as a string.
 * @returns The newly created filter function.
 */
function matchesPattern(str, regex) {
    return (0, filter_function_1.filterFunction)('matchesPattern', 'boolean', str, regex);
}
exports.matchesPattern = matchesPattern;
/* Date Functions */
/**
 * Build a filter function to get the fractional seconds of a date. Evaluates to decimal.
 * @param date - The date to get the fractional seconds for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function.
 */
function fractionalSeconds(date) {
    return (0, filter_function_1.filterFunction)('fractionalseconds', 'decimal', date);
}
exports.fractionalSeconds = fractionalSeconds;
/**
 * Build a filter function to get the signed number of minutes in the time zone offset. Evaluates to int.
 * @param date - The date to get the offset minutes for. This can either be a date (Moment) or a reference to a field.
 * @returns The newly created filter function.
 */
function totalOffsetMinutes(date) {
    return (0, filter_function_1.filterFunction)('totaloffsetminutes', 'decimal', date);
}
exports.totalOffsetMinutes = totalOffsetMinutes;
/**
 * Build a filter function to get the latest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function.
 */
function maxDateTime() {
    return (0, filter_function_1.filterFunction)('maxdatetime', 'decimal');
}
exports.maxDateTime = maxDateTime;
/**
 * Build a filter function to get the earliest possible point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function.
 */
function minDateTime() {
    return (0, filter_function_1.filterFunction)('mindatetime', 'decimal');
}
exports.minDateTime = minDateTime;
/**
 * Build a filter function to get the current point in time. Evaluates to DateTimeOffset.
 * @returns The newly created filter function.
 */
function now() {
    return (0, filter_function_1.filterFunction)('now', 'decimal');
}
exports.now = now;
/* Collection functions */
/**
 * Build a filter function to test whether a set is a subset of the other, i.e. whether the second parameter can be transformed into the first by reordering and / or removing items. Evaluates to boolean.
 * @param subset - The subset to test for. This can either be an array, a reference to a field or another filter function.
 * @param set - The set to test. This can either be an array, a reference to a field or another filter function.
 * @returns The newly created filter function.
 */
function hasSubset(subset, set) {
    return (0, filter_function_1.filterFunction)('hassubset', 'boolean', subset, set);
}
exports.hasSubset = hasSubset;
/**
 * Build a filter function to test whether a set is a subsequence of the other, i.e. whether the second parameter can be transformed into the first by removing items. Evaluates to boolean.
 * @param subsequence - The subsequence to test for. This can either be an array, a reference to a field or another filter function.
 * @param sequence - The sequence to test. This can either be an array, a reference to a field or another filter function.
 * @returns The newly created filter function.
 */
function hasSubsequence(subsequence, sequence) {
    return (0, filter_function_1.filterFunction)('hassubsequence', 'boolean', subsequence, sequence);
}
exports.hasSubsequence = hasSubsequence;
/**
 * TODO: totalseconds, time.
 */
/**
 * OData v4 specific filter functions.
 * @param deSerializers - DeSerializer used in the filter function.
 * @returns Object containing the filter functions.
 */
function filterFunctions(deSerializers = de_serializers_1.defaultDeSerializers) {
    return {
        ...(0, internal_1.filterFunctions)((0, de_serializers_1.mergeDefaultDeSerializersWith)(deSerializers)),
        contains,
        matchesPattern,
        fractionalSeconds,
        totalOffsetMinutes,
        maxDateTime,
        minDateTime,
        now,
        hasSubset,
        hasSubsequence
    };
}
exports.filterFunctions = filterFunctions;
//# sourceMappingURL=filter-functions.js.map