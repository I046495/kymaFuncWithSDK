"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFile = exports.getFileExtension = exports.readPrettierConfig = exports.defaultPrettierConfig = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const util_1 = require("@sap-cloud-sdk/util");
const prettier_1 = __importDefault(require("prettier"));
const util_2 = require("../util");
const { writeFile, readFile } = fs_1.promises;
const logger = (0, util_1.createLogger)('create-file');
/**
 * @internal
 */
exports.defaultPrettierConfig = {
    singleQuote: true,
    trailingComma: 'none',
    arrowParens: 'avoid',
    endOfLine: 'lf'
};
const prettierConfigCache = {};
/**
 * Read the prettier config and caches it.
 * @param prettierConfigPath - Path to the prettier config.
 * @returns Config or default.
 * @internal
 */
async function readPrettierConfig(prettierConfigPath) {
    if (prettierConfigPath && prettierConfigCache[prettierConfigPath]) {
        return prettierConfigCache[prettierConfigPath];
    }
    if (prettierConfigPath) {
        try {
            const config = await readFile(prettierConfigPath, { encoding: 'utf-8' });
            prettierConfigCache[prettierConfigPath] = JSON.parse(config);
            return prettierConfigCache[prettierConfigPath];
        }
        catch (e) {
            logger.warn(`Prettier config file not found: ${prettierConfigPath} - default is used.`);
            return exports.defaultPrettierConfig;
        }
    }
    logger.debug('Default prettier config is used.');
    return exports.defaultPrettierConfig;
}
exports.readPrettierConfig = readPrettierConfig;
const fileParserMap = {
    ts: 'typescript',
    md: 'markdown',
    json: 'json',
    js: 'espree',
    mdx: 'mdx',
    yml: 'yaml',
    yaml: 'yaml',
    'd.ts': 'typescript',
    'js.map': 'json',
    'd.ts.map': 'json'
};
/**
 * This method considers also double dots like `.map.js`
 * @param fileName
 * @returns The complete file extension containing multiple dots
 * @internal
 */
function getFileExtension(fileName) {
    return (0, path_1.parse)(fileName).base.split('.').slice(1).join('.');
}
exports.getFileExtension = getFileExtension;
async function formatWithPrettier(fileName, content, prettierOptions) {
    const fileExtension = getFileExtension(fileName);
    const parser = fileParserMap[fileExtension];
    if (parser) {
        try {
            return prettier_1.default.format(content, { ...prettierOptions, parser });
        }
        catch (e) {
            logger.warn(`Error in prettify file ${fileName} - emit unformatted content`);
            return content;
        }
    }
    logger.info(`No prettier-parser configured for file ${fileName} - skip prettier.`);
    return content;
}
function addCopyrightHeader(content, withCopyright) {
    if (!withCopyright) {
        return content;
    }
    return (0, util_1.codeBlock) `
${(0, util_2.getCopyrightHeader)()}
${content}
${util_1.unixEOL}
`;
}
/**
 * Write a file generated by the SAP Cloud SDK for JavaScript.
 * @param directoryPath - Path of the directory to write to.
 * @param fileName - Name of the file to write
 * @param content - Content to be written to the file. A copyright statement will be added to this.
 * @param overwrite - Whether or not existing files should be overwritten.
 * @param withCopyright - Whether the generated file contains the copyright information.
 * @internal
 */
async function createFile(directoryPath, fileName, content, options) {
    const { overwrite, prettierOptions, usePrettier = true } = options;
    try {
        // Our copyright header is only valid for source files i.e. typescript.
        const withCopyright = getFileExtension(fileName) === 'ts' ||
            getFileExtension(fileName) === 'd.ts';
        let adjusted = addCopyrightHeader(content, withCopyright);
        if (usePrettier) {
            adjusted = await formatWithPrettier(fileName, adjusted, prettierOptions);
        }
        return await writeFile((0, path_1.join)(directoryPath, fileName), adjusted, {
            encoding: 'utf8',
            flag: overwrite ? 'w' : 'wx'
        });
    }
    catch (err) {
        const recommendation = err.code === 'EEXIST' && !overwrite
            ? ' File already exists. If you want to allow overwriting files, enable the `overwrite` flag.'
            : '';
        throw new util_1.ErrorWithCause(`Could not write file "${fileName}".${recommendation}`, err);
    }
}
exports.createFile = createFile;
//# sourceMappingURL=create-file.js.map