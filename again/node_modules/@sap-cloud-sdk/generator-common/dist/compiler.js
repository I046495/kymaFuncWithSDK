"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.readCompilerOptions = exports.readIncludeExcludeWithDefaults = exports.transpileDirectory = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const os_1 = require("os");
const util_1 = require("@sap-cloud-sdk/util");
const typescript_1 = require("typescript");
const glob_1 = require("glob");
const file_writer_1 = require("./file-writer");
const logger = (0, util_1.createLogger)('compiler');
const { mkdir } = fs_1.promises;
/**
 * Executes the TypeScript compilation for the given directory.
 * It recursively compiles all files ending with .ts
 * @param path - Directory to be compiled.
 * @param compilerOptions - Compiler options to be used
 * @param includeExclude - Included and excluded files for compilation
 * @internal
 */
async function transpileDirectory(path, { compilerOptions, createFileOptions }, includeExclude = defaultIncludeExclude) {
    logger.verbose(`Transpiling files in the directory: ${path} started.`);
    const includes = includeExclude.include.length > 1
        ? `{${includeExclude.include.join(',')}}`
        : includeExclude.include[0];
    const excludes = includeExclude.exclude.length > 1
        ? `{${includeExclude.exclude.join(',')}}`
        : includeExclude.exclude[0];
    const allFiles = await (0, glob_1.glob)(includes, {
        ignore: excludes,
        cwd: path
    });
    const program = await (0, typescript_1.createProgram)(allFiles.map(file => (0, path_1.resolve)(path, file)), compilerOptions);
    // The write file handler does not support async function hence the work around with the outer promise list.
    const fileWriterPromises = [];
    const prettierWriter = (fileName, text) => {
        const parsed = (0, path_1.parse)(fileName);
        const promise = mkdir(parsed.dir, { recursive: true }).then(async () => {
            // The transpile process creates `.map.js`, `.js` and `.d.ts` files
            // All not emitted files like .md or .json should be already formatted using prettier on creation.
            // Formatting .js files could break source map -> skip these.
            // The .map files are not human-readable and formatting increases file size -> skip these.
            const usePrettier = createFileOptions.usePrettier === false
                ? false
                : (0, file_writer_1.getFileExtension)(fileName) === 'd.ts';
            return (0, file_writer_1.createFile)(parsed.dir, parsed.base, text, {
                ...createFileOptions,
                usePrettier
            });
        });
        fileWriterPromises.push(promise);
    };
    const emitResult = program.emit(undefined, prettierWriter);
    await Promise.all(fileWriterPromises);
    const allDiagnostics = (0, typescript_1.getPreEmitDiagnostics)(program).concat(emitResult.diagnostics);
    if (allDiagnostics.length > 0) {
        throw new Error(`Compilation Errors:${os_1.EOL}${getErrorList(allDiagnostics).join(os_1.EOL)}`);
    }
    logger.verbose(`Transpiling files in directory: ${path} finished.`);
}
exports.transpileDirectory = transpileDirectory;
function getErrorList(diagnostics) {
    return diagnostics.map(diagnostic => {
        const text = typeof diagnostic.messageText === 'string'
            ? diagnostic.messageText
            : diagnostic.messageText.messageText;
        if (diagnostic.file) {
            const { lineNumber, linePosition } = findPositions(diagnostic.file.statements, diagnostic.start);
            return `${diagnostic.file.fileName}:${lineNumber}:${linePosition} - error TS${diagnostic.code}: ${text}`;
        }
        return `error TS${diagnostic.code}: ${text}`;
    });
}
function findPositions(statements, errorPosition) {
    if (!statements || statements.length === 0 || !errorPosition) {
        return { lineNumber: 0, linePosition: 0 };
    }
    let response;
    statements.forEach((statement, index) => {
        if (statement.pos <= errorPosition && errorPosition < statement.end) {
            response = {
                lineNumber: index + 1,
                linePosition: errorPosition - statement.pos
            };
        }
    });
    if (!response) {
        throw new Error('Can not find error position in list of statements.');
    }
    return response;
}
async function readTsConfig(pathToTsConfig) {
    const fullPath = (0, path_1.parse)(pathToTsConfig).base === 'tsconfig.json'
        ? pathToTsConfig
        : (0, path_1.resolve)(pathToTsConfig, 'tsconfig.json');
    if (!(0, fs_1.existsSync)(fullPath)) {
        throw new Error(`No tsconfig found under path ${fullPath}`);
    }
    return JSON.parse(await fs_1.promises.readFile(fullPath, {
        encoding: 'utf8'
    }));
}
const defaultIncludeExclude = {
    include: ['**/*.ts'],
    exclude: ['dist/**/*', '**/*.d.ts', '**/*.spec.ts', 'node_modules/**/*']
};
/**
 * Reads the include and exclude property from the tsconfig.json using  ['**\/*.ts'] and ["dist/**\/*", "**\/*.spec.ts", "**\/*.d.ts", "node_modules/**\/*"] as default values.
 * @param pathToTsConfig - Folder containing or path to a tsconfig.json files
 * @returns IncludeExclude options for include and exclude files for compilation
 * @internal
 */
async function readIncludeExcludeWithDefaults(pathToTsConfig) {
    const tsConfig = await readTsConfig(pathToTsConfig);
    return {
        include: tsConfig.include || defaultIncludeExclude.include,
        exclude: tsConfig.exclude || defaultIncludeExclude.exclude
    };
}
exports.readIncludeExcludeWithDefaults = readIncludeExcludeWithDefaults;
/**
 * Reads and parses the compiler options a tsconfig.json.
 * @param pathToTsConfig - Folder containing or path to a tsconfig.json files
 * @returns Compiler options from the tsconfig.json
 * @internal
 */
async function readCompilerOptions(pathToTsConfig) {
    const options = (await readTsConfig(pathToTsConfig))['compilerOptions'] || {};
    if (options.moduleResolution) {
        options.moduleResolution = parseModuleResolutionKind(options.moduleResolution);
    }
    if (options.lib && options.lib.length > 0) {
        options.lib = options.lib.map(name => `lib.${name}.d.ts`);
    }
    if (options.target) {
        options.target = parseScriptTarget(options.target);
    }
    if (options.module) {
        options.module = parseModuleKind(options.module);
    }
    return options;
}
exports.readCompilerOptions = readCompilerOptions;
function parseModuleResolutionKind(input) {
    const moduleResolution = input.toLowerCase();
    if (moduleResolution === 'node') {
        return typescript_1.ModuleResolutionKind.NodeJs;
    }
    if (moduleResolution === 'node16') {
        return typescript_1.ModuleResolutionKind.Node16;
    }
    if (moduleResolution === 'nodenext') {
        return typescript_1.ModuleResolutionKind.NodeNext;
    }
    return typescript_1.ModuleResolutionKind.Classic;
}
function parseScriptTarget(input) {
    const mapping = {
        es3: typescript_1.ScriptTarget.ES3,
        es5: typescript_1.ScriptTarget.ES5,
        esnext: typescript_1.ScriptTarget.ESNext,
        es2015: typescript_1.ScriptTarget.ES2015,
        es2016: typescript_1.ScriptTarget.ES2016,
        es2017: typescript_1.ScriptTarget.ES2017,
        es2018: typescript_1.ScriptTarget.ES2018,
        es2019: typescript_1.ScriptTarget.ES2019,
        es2020: typescript_1.ScriptTarget.ES2020,
        es2021: typescript_1.ScriptTarget.ES2021
    };
    if (mapping[input.toLowerCase()]) {
        return mapping[input.toLowerCase()];
    }
    logger.warn(`The selected ES target ${input} is not found - Fallback es2021 used`);
    return typescript_1.ScriptTarget.ES2021;
}
function parseModuleKind(input) {
    const mapping = {
        commonjs: typescript_1.ModuleKind.CommonJS,
        amd: typescript_1.ModuleKind.AMD,
        es2015: typescript_1.ModuleKind.ES2015,
        es2020: typescript_1.ModuleKind.ES2020,
        esnext: typescript_1.ModuleKind.ESNext
    };
    if (mapping[input.toLowerCase()]) {
        return mapping[input.toLowerCase()];
    }
    logger.warn(`The selected module kind ${input} is not found - Fallback commonJS used`);
    return typescript_1.ModuleKind.CommonJS;
}
//# sourceMappingURL=compiler.js.map