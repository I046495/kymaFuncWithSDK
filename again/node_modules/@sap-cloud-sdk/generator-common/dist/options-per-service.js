"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.writeOptionsPerService = exports.getServiceOptions = exports.getRelPathWithPosixSeparator = exports.getOptionsPerService = exports.getOriginalOptionsPerService = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const util_1 = require("@sap-cloud-sdk/util");
const file_writer_1 = require("./file-writer");
const util_2 = require("./util");
const logger = (0, util_1.createLogger)('options-per-service');
const { readFile, mkdir } = fs_1.promises;
/**
 * Get the options per service from the given path or an empty object if no path was given.
 * @param configPath - Path to the given per service configuration or `undefined`, if no path was given.
 * @returns The parsed configuration for all services.
 * @internal
 */
async function getOriginalOptionsPerService(configPath) {
    return configPath && (0, fs_1.existsSync)(configPath)
        ? JSON.parse(await readFile(configPath, 'utf8'))
        : {};
}
exports.getOriginalOptionsPerService = getOriginalOptionsPerService;
/**
 * Get the options per service for given service specifications.
 * If optionsPerBasePath is not given, default values are used for the services.
 * If optionsPerBasePath is given, existing values for the services are used.
 * @param inputPaths - Service spec file paths.
 * @param options - Generator options.
 * @returns The parsed options per service.
 * @internal
 */
async function getOptionsPerService(inputPaths, { optionsPerService, skipValidation }) {
    const originalOptionsPerService = await getOriginalOptionsPerService(optionsPerService);
    const uniqueNameGenerator = new util_1.UniqueNameGenerator('-');
    const directoryNamesByPaths = getDirectoryNamesByPaths(inputPaths, originalOptionsPerService);
    if (!skipValidation) {
        validateDirectoryNames(directoryNamesByPaths);
    }
    const optsPerService = inputPaths.reduce((previousOptions, inputPath) => {
        const relativePath = getRelPathWithPosixSeparator(inputPath);
        const uniqueDirName = uniqueNameGenerator.generateAndSaveUniqueName(directoryNamesByPaths[inputPath]);
        previousOptions[relativePath] = getServiceOptions(uniqueDirName, skipValidation, originalOptionsPerService[relativePath]);
        return previousOptions;
    }, {});
    return optsPerService;
}
exports.getOptionsPerService = getOptionsPerService;
function getDirectoryNamesByPaths(inputPaths, originalOptionsPerService) {
    return inputPaths.reduce((directoryNamesByPaths, inputPath) => {
        const relativePath = getRelPathWithPosixSeparator(inputPath);
        const directoryName = originalOptionsPerService[relativePath]?.directoryName ||
            parseDirectoryName(relativePath);
        directoryNamesByPaths[inputPath] = directoryName;
        return directoryNamesByPaths;
    }, {});
}
/**
 * Gives the relative path with respect to process.cwd() using posix file separator '/'.
 * @param absolutePath - The absolute path
 * @returns The relative path
 * @internal
 */
function getRelPathWithPosixSeparator(absolutePath) {
    return (0, path_1.relative)(process.cwd(), absolutePath).split(path_1.sep).join(path_1.posix.sep);
}
exports.getRelPathWithPosixSeparator = getRelPathWithPosixSeparator;
function getPathsByDirName(dirNamesByPaths) {
    return Object.entries(dirNamesByPaths).reduce((pathsByDirName, [inputPath, dirName]) => {
        if (!pathsByDirName[dirName]) {
            pathsByDirName[dirName] = [];
        }
        pathsByDirName[dirName].push(inputPath);
        return pathsByDirName;
    }, {});
}
function validateDirectoryNames(dirNamesByPaths) {
    const originalDirNames = Object.values(dirNamesByPaths);
    const uniqueDirNames = (0, util_1.unique)(originalDirNames);
    const hasDuplicates = originalDirNames.length !== uniqueDirNames.length;
    if (hasDuplicates) {
        const pathsByDirName = getPathsByDirName(dirNamesByPaths);
        const duplicates = Object.entries(pathsByDirName).filter(([, paths]) => paths.length > 1);
        const duplicatesList = duplicates
            .map(([dirName, paths]) => `\t\tDirectory name: '${dirName}', specifications: [\n${paths
            .map(path => `\t\t\t${path}`)
            .join(',\n')}\n\t\t]`)
            .join('\n');
        const errorMessage = `Duplicate service file names would result in duplicate directory names. Customize directory names with \`optionsPerService\` or enable automatic name adjustment with \`skipValidation\`.\n\tDuplicates:\n${duplicatesList}`;
        throw new Error(errorMessage);
    }
}
/**
 * Parse the name of the service directory based on the file path.
 * @param filePath - Path of the service specification.
 * @returns The parsed name.
 */
function parseDirectoryName(filePath) {
    return (0, path_1.parse)(filePath).name.replace(/-openapi$/, '');
}
/**
 * Get the options for one service based on the options per service and the input file path.
 * If the file path does not exist in the options a default config is created.
 * If the service options for a file path are given only partially, default values are added for the missing values.
 * @param directoryName - The directory name of the according service.
 * @param serviceOptions - The original options for this service as specified in the per service options.
 * @returns Service options.
 * @internal
 */
function getServiceOptions(directoryName, skipValidation, serviceOptions) {
    if (serviceOptions?.packageName) {
        const packageName = (0, util_2.npmCompliantName)(serviceOptions?.packageName);
        if (skipValidation) {
            (0, util_2.validateNpmCompliance)(serviceOptions?.packageName);
        }
        else if (packageName !== serviceOptions?.packageName) {
            throw new Error(`The intended package name ${serviceOptions.packageName} is not npm compliant. Either change to a compliant value e.g. '${packageName}' in your options per service configuration or execute with '--skipValidation'.`);
        }
    }
    const defaultConfig = {
        packageName: (0, util_2.npmCompliantName)(directoryName),
        directoryName
    };
    return {
        ...defaultConfig,
        ...serviceOptions
    };
}
exports.getServiceOptions = getServiceOptions;
/**
 * @internal
 */
async function writeOptionsPerService(filePath, optionsPerService, options) {
    logger.verbose('Generating options per service.');
    const dir = (0, path_1.dirname)(filePath);
    await mkdir(dir, { recursive: true });
    await (0, file_writer_1.createFile)(dir, (0, path_1.basename)(filePath), (0, util_1.formatJson)({
        ...(await getOriginalOptionsPerService(filePath)),
        ...optionsPerService
    }), {
        overwrite: true,
        prettierOptions: await (0, file_writer_1.readPrettierConfig)(options.prettierConfig)
    });
}
exports.writeOptionsPerService = writeOptionsPerService;
//# sourceMappingURL=options-per-service.js.map