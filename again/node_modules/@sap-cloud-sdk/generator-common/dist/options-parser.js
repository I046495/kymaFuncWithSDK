"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOptions = exports.getOptionsWithoutDefaults = exports.resolvePath = exports.resolveOptionsPerService = exports.getInputFilePaths = exports.buildResolveInputGlob = exports.resolveRequiredPath = exports.resolveGlob = void 0;
const path_1 = require("path");
const fs_1 = require("fs");
const util_1 = require("@sap-cloud-sdk/util");
const logger = (0, util_1.createLogger)('generator-options');
const glob_1 = require("glob");
/**
 * Resolves a string using glob notation.
 * If a config is given in generatorOptions, the glob working directory is considered relative to this config.
 * @internal
 * @param arg - Value for the string for which the glob is resolved.
 * @param options - Generator options.
 */
function resolveGlob(arg, options) {
    if (!arg) {
        return [];
    }
    const inputPath = options.config
        ? (0, path_1.resolve)((0, path_1.dirname)(options.config), arg.toString())
        : (0, path_1.resolve)(arg.toString());
    // Glob expressions only support unix style path separator (/). The below adjustment is made so it works on Windows. https://github.com/isaacs/node-glob#windows
    return resolveFilePaths((0, glob_1.globSync)(inputPath.split(path_1.sep).join(path_1.posix.sep), { nocase: false }));
}
exports.resolveGlob = resolveGlob;
/**
 * Resolves arguments that represent paths to an absolute path as a `string`. Only works for required options.
 * @internal
 * @param arg - Path argument as passed by the user.
 * @param options - Options as passed by the user.
 * @returns Absolute path as a `string`.
 */
function resolveRequiredPath(arg, options) {
    return options.config
        ? (0, path_1.resolve)((0, path_1.dirname)(options.config), arg.toString())
        : (0, path_1.resolve)(arg.toString());
}
exports.resolveRequiredPath = resolveRequiredPath;
/**
 * Builds a glob resolver function for OData or OpenApi
 * @internal
 * @param serviceType - For which service the glob resolver is build.
 * @returns Function for resolving inputs Globs for OData or Openapi
 */
function buildResolveInputGlob(serviceType) {
    /**
     * Resolves input string using glob notation.
     * @internal
     * @param arg - Path argument as passed by the user.
     * @param options - Options as passed by the user.
     * @returns Absolute path as a `string`.
     */
    return function resolveInputGlob(arg, options) {
        const inputPath = options.config
            ? (0, path_1.resolve)((0, path_1.dirname)(options.config), arg.toString())
            : (0, path_1.resolve)(arg.toString());
        const resolvedServiceFilePaths = getInputFilePaths(inputPath.split(path_1.sep).join(path_1.posix.sep), serviceType);
        if (!resolvedServiceFilePaths.length) {
            logger.warn(`No service definition files found using '${arg}' as input`);
        }
        return resolvedServiceFilePaths;
    };
}
exports.buildResolveInputGlob = buildResolveInputGlob;
function getRawInputFilePaths(input, serviceType) {
    if ((0, glob_1.hasMagic)(input)) {
        const regex = serviceType === 'OData'
            ? /(.xml|.edmx|.XML|.EDMX)$/
            : /(.json|.JSON|.yaml|.YAML|.yml|.YML)$/;
        return (0, glob_1.globSync)(input, { nocase: false }).filter(path => regex.test(path));
    }
    if ((0, fs_1.lstatSync)(input).isDirectory()) {
        const regex = serviceType === 'OData'
            ? '**/*.{xml,edmx,XML,EDMX}'
            : '**/*.{json,JSON,yaml,YAML,yml,YML}';
        return (0, glob_1.globSync)(path_1.posix.join(input, regex), { nocase: false });
    }
    return [input];
}
/**
 * Recursively searches through a given input path and returns all file paths as a string array.
 * @param input - the path to the input directory.
 * @returns all file paths as a string array.
 * @internal
 */
function getInputFilePaths(input, serviceType) {
    return resolveFilePaths(getRawInputFilePaths(input, serviceType));
}
exports.getInputFilePaths = getInputFilePaths;
function resolveFilePaths(filePaths) {
    return filePaths.map(s => (0, path_1.resolve)(s)).sort();
}
/**
 * Resolve the optionsPerService. If a directory is given the default name 'options-per-service.json' is used.
 * @internal
 * @param arg
 * @param options
 */
function resolveOptionsPerService(arg, options) {
    if (typeof arg !== 'undefined') {
        const isFilePath = ((0, fs_1.existsSync)(arg) && (0, fs_1.lstatSync)(arg).isFile()) || !!(0, path_1.extname)(arg);
        return resolveRequiredPath(isFilePath ? arg : (0, path_1.join)(arg, 'options-per-service.json'), options);
    }
}
exports.resolveOptionsPerService = resolveOptionsPerService;
/**
 * Same as `resolveRequiredPath`, but for non-required options.
 * @internal
 * @param arg - Path argument as passed by the user, or `undefined` if nothing was passed.
 * @param options - Options as passed by the user.
 * @returns Absolute path as a `string` or `undefined`.
 */
function resolvePath(arg, options) {
    return arg ? resolveRequiredPath(arg, options) : undefined;
}
exports.resolvePath = resolvePath;
/**
 * @internal
 * Remove defaults from CLI options. This is necessary to handle default setting on our own.
 * @param options - CLI options, record, that maps option name to option config.
 * @returns CLI options without default values.
 */
function getOptionsWithoutDefaults(options) {
    return Object.entries(options).reduce((optionsWithoutDefaults, [name, option]) => {
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        const { default: def, coerce, ...optionWithoutDefault } = option;
        const describe = def === undefined
            ? optionWithoutDefault.describe
            : `${optionWithoutDefault.describe}\n[Default: ${def}]`;
        return {
            ...optionsWithoutDefaults,
            [name]: {
                ...optionWithoutDefault,
                describe
            }
        };
    }, {});
}
exports.getOptionsWithoutDefaults = getOptionsWithoutDefaults;
/**
 * @internal
 * Parse options for programmatic and CLI use.
 * Warn, if deprecated options are used or duplicate.
 * Adds defaults for options not set by the user.
 * @param options - Available CLI options along with their configuration.
 * @param userOptions - Options as set by user, either through the CLI or programmatically.
 * @returns Parsed options with default values.
 */
function parseOptions(options, userOptions) {
    return new OptionsParser(options, userOptions).parseOptions();
}
exports.parseOptions = parseOptions;
class OptionsParser {
    constructor(options, userOptions) {
        this.options = options;
        this.userOptions = userOptions;
    }
    parseOptions() {
        this.warnIfDeprecatedOptionsUsed();
        this.warnIfDuplicateOptionsUsed();
        const parsedOptions = this.sanitizeIfReplacedOptionsUsed();
        return this.addDefaults(parsedOptions);
    }
    addDefaults(parsedOptions) {
        Object.entries(this.options).forEach(([name, option]) => {
            if ('default' in option) {
                parsedOptions[name] = parsedOptions[name] ?? option.default;
            }
            if ('coerce' in option) {
                parsedOptions[name] = option.coerce?.(parsedOptions[name], parsedOptions);
            }
        });
        return parsedOptions;
    }
    getDeprecatedOptionsInUse() {
        return Object.keys(this.options)
            .filter(name => this.options[name].deprecated)
            .filter(name => Object.keys(this.userOptions).includes(name));
    }
    getReplacedOptionsUsed() {
        return Object.keys(this.options)
            .filter(name => this.options[name].replacedBy)
            .filter(name => Object.keys(this.userOptions).includes(name));
    }
    getReplacingOptionName(replacedOptionName) {
        const replacingOptionName = this.options[replacedOptionName].replacedBy;
        if (!replacingOptionName) {
            throw new Error(`Cannot get replaced option for deprecated option ${replacedOptionName}.`);
        }
        return replacingOptionName;
    }
    getDuplicateOptionsUsed() {
        const oldOptionsUsed = this.getReplacedOptionsUsed();
        if (oldOptionsUsed.length) {
            const oldNewNames = oldOptionsUsed.map(name => ({
                oldName: name,
                newName: this.getReplacingOptionName(name)
            }));
            return oldNewNames.filter(({ newName }) => Object.keys(this.userOptions).includes(newName));
        }
        return [];
    }
    /**
     * @internal
     * Logs a warning if deprecated options are used.
     * @param args - Either the command line arguments or the config passed for programmatic use. An array implicates command line arguments, while objects represent the programmatic config.
     * @param options - Available generator options.
     */
    warnIfDeprecatedOptionsUsed() {
        const deprecatedOptionsInUse = this.getDeprecatedOptionsInUse();
        if (deprecatedOptionsInUse.length) {
            const logs = deprecatedOptionsInUse
                .map(name => `\t${name}: ${this.options[name].deprecated}`)
                .join('\n');
            logger.warn(`Deprecated options used:\n${logs}`);
        }
    }
    warnIfDuplicateOptionsUsed() {
        const duplicateOptionsUsed = this.getDuplicateOptionsUsed();
        if (duplicateOptionsUsed.length) {
            const log = duplicateOptionsUsed
                .map(({ oldName, newName }) => `\t${oldName} was replaced by ${newName}.`)
                .join('\n');
            logger.warn(`Duplicate options used:\n${log}`);
        }
    }
    sanitizeIfReplacedOptionsUsed() {
        const replacedOptionsUsed = this.getReplacedOptionsUsed();
        return Object.entries(this.userOptions).reduce((opts, [name, value]) => {
            if (replacedOptionsUsed.includes(name)) {
                const replacedByName = this.getReplacingOptionName(name);
                return replacedByName in this.userOptions
                    ? // ignore the deprecated value => it will be set by the correct option
                        opts
                    : // set the replaced value for the new name
                        { ...opts, [replacedByName]: value };
            }
            return { ...opts, [name]: value };
        }, {});
    }
}
//# sourceMappingURL=options-parser.js.map