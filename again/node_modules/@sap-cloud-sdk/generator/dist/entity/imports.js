"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.otherEntityImports = exports.entityImportDeclarations = void 0;
const ts_morph_1 = require("ts-morph");
const imports_1 = require("../imports");
const operations_1 = require("../operations");
/**
 * @internal
 */
function entityImportDeclarations(entity, service, oDataVersion) {
    if (oDataVersion === 'v4') {
        return (0, imports_1.mergeImportDeclarations)([
            (0, imports_1.odataImportDeclarationTsMorph)(['Entity', 'DefaultDeSerializers', 'DeSerializers', 'DeserializedType'], oDataVersion),
            ...(0, imports_1.complexTypeImportDeclarations)(entity.properties),
            {
                namedImports: [`${entity.className}Api`],
                moduleSpecifier: `./${entity.className}Api`,
                kind: ts_morph_1.StructureKind.ImportDeclaration,
                isTypeOnly: true
            },
            ...(0, operations_1.operationDeclarations)(service, entity.operations),
            ...(0, imports_1.enumTypeImportDeclarations)(entity.properties)
        ]);
    }
    return [
        (0, imports_1.odataImportDeclarationTsMorph)(['Entity', 'DefaultDeSerializers', 'DeSerializers', 'DeserializedType'], oDataVersion),
        ...(0, imports_1.complexTypeImportDeclarations)(entity.properties),
        {
            namedImports: [`${entity.className}Api`],
            moduleSpecifier: `./${entity.className}Api`,
            kind: ts_morph_1.StructureKind.ImportDeclaration,
            isTypeOnly: true
        },
        ...(0, imports_1.enumTypeImportDeclarations)(entity.properties)
    ];
}
exports.entityImportDeclarations = entityImportDeclarations;
/**
 * @internal
 */
function otherEntityImports(entity, service) {
    return Array.from(new Set(entity.navigationProperties.map(n => n.to)))
        .map(to => {
        const matchedEntity = service.entities.find(e => e.entitySetName === to);
        if (!matchedEntity) {
            throw Error(`Failed to find the entity from the service: ${JSON.stringify(service)} for entity ${entity}`);
        }
        return matchedEntity.className;
    })
        .filter(name => name !== entity.className)
        .map(name => otherEntityImport(name));
}
exports.otherEntityImports = otherEntityImports;
function otherEntityImport(name) {
    return {
        kind: ts_morph_1.StructureKind.ImportDeclaration,
        namedImports: [name, `${name}Type`],
        moduleSpecifier: `./${name}`
    };
}
//# sourceMappingURL=imports.js.map