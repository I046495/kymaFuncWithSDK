"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getPropertyType = exports.entityClass = void 0;
const ts_morph_1 = require("ts-morph");
const internal_prefix_1 = require("../internal-prefix");
const operations_1 = require("../operations");
const typedoc_1 = require("../typedoc");
/**
 * @internal
 */
function entityClass(entity, service) {
    return {
        kind: ts_morph_1.StructureKind.Class,
        name: `${entity.className}<T extends DeSerializers = DefaultDeSerializers>`,
        ctors: [
            {
                parameters: [
                    {
                        name: '_entityApi',
                        type: `${entity.className}Api<T>`,
                        isReadonly: true
                    }
                ],
                statements: ['super(_entityApi);']
            }
        ],
        extends: 'Entity',
        implements: [`${entity.className}Type<T>`],
        properties: [
            ...staticProperties(entity, service),
            ...properties(entity),
            ...navProperties(entity, service)
        ],
        methods: boundOperations(entity.operations, service),
        isExported: true,
        docs: [(0, typedoc_1.addLeadingNewline)((0, typedoc_1.getEntityDescription)(entity, service))]
    };
}
exports.entityClass = entityClass;
function staticProperties(entity, service) {
    return [entityName(entity), defaultBasePath(service), keys(entity)];
}
function entityName(entity) {
    return {
        kind: ts_morph_1.StructureKind.Property,
        name: (0, internal_prefix_1.prependPrefix)('entityName'),
        isStatic: true,
        initializer: `'${entity.entitySetName}'`,
        docs: [(0, typedoc_1.addLeadingNewline)(`Technical entity name for ${entity.className}.`)]
    };
}
function defaultBasePath(service) {
    return {
        kind: ts_morph_1.StructureKind.Property,
        name: (0, internal_prefix_1.prependPrefix)('defaultBasePath'),
        isStatic: true,
        initializer: `'${service.serviceOptions.basePath}'`,
        docs: [(0, typedoc_1.addLeadingNewline)('Default url path for the according service.')]
    };
}
function keys(entity) {
    return {
        kind: ts_morph_1.StructureKind.Property,
        name: (0, internal_prefix_1.prependPrefix)('keys'),
        isStatic: true,
        initializer: `[${entity.keys
            .map(key => `'${key.originalName}'`)
            .join(',')}]`,
        docs: [
            (0, typedoc_1.addLeadingNewline)(`All key fields of the ${entity.className} entity`)
        ]
    };
}
function properties(entity) {
    return entity.properties.map(prop => property(prop));
}
function boundOperations(operations, service) {
    return operations.map(operation => ({
        kind: ts_morph_1.StructureKind.Method,
        ...(0, operations_1.operationFunctionBase)(operation, service)
    }));
}
function property(prop) {
    return {
        kind: ts_morph_1.StructureKind.Property,
        name: prop.instancePropertyName + (prop.nullable ? '?' : '!'),
        type: getPropertyType(prop),
        docs: [
            (0, typedoc_1.addLeadingNewline)((0, typedoc_1.getPropertyDescription)(prop, {
                nullable: prop.nullable,
                maxLength: prop.maxLength
            }))
        ]
    };
}
/**
 * @internal
 * @param prop - Property type in Vdm form.
 * @returns Property type as string.
 */
function getPropertyType(prop) {
    if (prop.isCollection) {
        if (prop.isComplex) {
            return `${prop.jsType}<T>[]` + getNullableSuffix(prop);
        }
        if (prop.isEnum) {
            return `${prop.jsType}[]` + getNullableSuffix(prop);
        }
        return `DeserializedType<T, '${prop.edmType}'>[]` + getNullableSuffix(prop);
    }
    if (prop.isComplex) {
        return `${prop.jsType}<T>` + getNullableSuffix(prop);
    }
    if (prop.isEnum) {
        return `${prop.jsType}` + getNullableSuffix(prop);
    }
    return `DeserializedType<T, '${prop.edmType}'>` + getNullableSuffix(prop);
}
exports.getPropertyType = getPropertyType;
function getNullableSuffix(prop) {
    return prop.nullable ? ' | null' : '';
}
function navProperties(entity, service) {
    return entity.navigationProperties.map(navProp => navProperty(navProp, service));
}
function navProperty(navProp, service) {
    const entity = service.entities.find(e => e.entitySetName === navProp.to);
    if (!entity) {
        throw Error(`Failed to find the entity from the service: ${JSON.stringify(service)} for nav property ${navProp}`);
    }
    return {
        kind: ts_morph_1.StructureKind.Property,
        name: navProp.instancePropertyName + (navProp.isCollection ? '!' : '?'),
        type: entity.className + '<T>' + (navProp.isCollection ? '[]' : ' | null'),
        docs: [(0, typedoc_1.addLeadingNewline)((0, typedoc_1.getNavPropertyDescription)(navProp))]
    };
}
//# sourceMappingURL=class.js.map