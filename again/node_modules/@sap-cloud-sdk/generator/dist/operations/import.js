"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.operationDeclarations = void 0;
const ts_morph_1 = require("ts-morph");
const voca_1 = __importDefault(require("voca"));
const imports_1 = require("../imports");
const common_1 = require("../edmx-to-vdm/common");
const response_transformer_function_1 = require("./response-transformer-function");
function complexTypeRelatedImports(returnTypes) {
    return returnTypes.some(returnType => returnType.returnTypeCategory === 'complex-type')
        ? ['entityDeserializer']
        : [];
}
function edmRelatedImports(returnTypes) {
    return returnTypes.some(returnType => returnType.returnTypeCategory === 'edm-type')
        ? ['edmToTs']
        : [];
}
function responseTransformerImports(returnTypes) {
    return returnTypes.map(returnType => (0, common_1.cannotDeserialize)(returnType)
        ? 'throwErrorWhenReturnTypeIsUnionType'
        : (0, response_transformer_function_1.responseTransformerFunctionName)(returnType));
}
function returnTypeImports(returnTypes) {
    return (0, imports_1.mergeImportDeclarations)(returnTypes
        .filter(returnType => returnType.returnTypeCategory !== 'edm-type' &&
        returnType.returnTypeCategory !== 'void' &&
        returnType.returnTypeCategory !== 'never')
        .reduce((imports, returnType) => [...imports, ...returnTypeImport(returnType)], []));
}
function returnTypeImport(returnType) {
    const typeImports = [
        {
            kind: ts_morph_1.StructureKind.ImportDeclaration,
            namedImports: [returnType.returnType],
            moduleSpecifier: `./${returnType.returnType}`
        }
    ];
    if (returnType.returnTypeCategory === 'entity') {
        return [
            ...typeImports,
            {
                kind: ts_morph_1.StructureKind.ImportDeclaration,
                namedImports: [`${returnType.returnType}Api`],
                moduleSpecifier: `./${returnType.returnType}Api`
            }
        ];
    }
    return typeImports;
}
/**
 * @internal
 */
function operationDeclarations({ oDataVersion, className }, operations = []) {
    if (!operations.length) {
        return [];
    }
    const parameters = operations.flatMap(({ parameters: params }) => params);
    const returnTypes = operations.map(({ returnType }) => returnType);
    const includesBound = !!operations.filter(operation => operation.isBound)
        .length;
    const includesUnbound = !!operations.filter(operation => !operation.isBound)
        .length;
    const hasOperationWithParameters = operations.some(operation => operation.parameters.length);
    if (includesUnbound && includesBound) {
        throw new Error('Bound and unbound operations found in generation - this should not happen.');
    }
    const serviceImport = includesBound
        ? []
        : [
            {
                kind: ts_morph_1.StructureKind.ImportDeclaration,
                namedImports: [voca_1.default.decapitalize(className)],
                moduleSpecifier: './service'
            }
        ];
    return [
        ...(0, imports_1.externalImportDeclarationsTsMorph)(parameters),
        (0, imports_1.odataImportDeclarationTsMorph)([
            ...edmRelatedImports(returnTypes),
            ...complexTypeRelatedImports(returnTypes),
            ...responseTransformerImports(returnTypes),
            'DeSerializers',
            'DefaultDeSerializers',
            'defaultDeSerializers',
            ...(0, imports_1.propertyTypeImportNames)(parameters),
            ...(hasOperationWithParameters ? ['OperationParameter'] : []),
            ...(includesUnbound ? ['OperationRequestBuilder'] : []),
            ...(includesBound ? ['BoundOperationRequestBuilder'] : [])
        ], oDataVersion),
        ...serviceImport,
        ...returnTypeImports(returnTypes)
    ];
}
exports.operationDeclarations = operationDeclarations;
//# sourceMappingURL=import.js.map