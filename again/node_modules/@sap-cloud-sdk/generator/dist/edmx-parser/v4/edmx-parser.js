"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseOperations = exports.parseOperationImports = exports.parseEntitySetsV4 = exports.parseEntityType = exports.parseEnumTypes = exports.parseComplexTypesV4 = exports.joinTypesWithBaseTypes = exports.joinComplexTypes = exports.joinEntityTypes = void 0;
const voca_1 = __importDefault(require("voca"));
const edmx_parser_1 = require("../common/edmx-parser");
const generator_utils_1 = require("../../generator-utils");
const edmx_to_vdm_util_1 = require("../../edmx-to-vdm/edmx-to-vdm-util");
/**
 * @internal
 */
function joinEntityTypes(entityType, baseType) {
    // TODO: only join properties / nav properties of the respective type
    return {
        ...entityType,
        Key: {
            PropertyRef: [...entityType.Key.PropertyRef, ...baseType.Key.PropertyRef]
        },
        Property: [...entityType.Property, ...baseType.Property],
        NavigationProperty: [
            ...entityType.NavigationProperty,
            ...baseType.NavigationProperty
        ]
    };
}
exports.joinEntityTypes = joinEntityTypes;
/**
 * @internal
 */
function joinComplexTypes(complexType, baseType) {
    return {
        ...complexType,
        Property: [...complexType.Property, ...baseType.Property]
    };
}
exports.joinComplexTypes = joinComplexTypes;
/**
 * @internal
 */
function joinTypesWithBaseTypes(types, joinTypes) {
    return types.map(type => joinTypeWithBaseType(type, types, joinTypes));
}
exports.joinTypesWithBaseTypes = joinTypesWithBaseTypes;
/**
 * Recursively adds the base type data to the current type.
 * @param type - An EDMX type that can have a base type (e.g. EntityType or ComplexType).
 * @param types - All parsed EDMX types.
 * @param joinTypes - Function to ultimately join types.
 * @returns The enriched type (type + base type).
 */
function joinTypeWithBaseType(type, types, joinTypes) {
    if (type.BaseType) {
        const baseType = types.find(e => e.Name === (0, edmx_to_vdm_util_1.stripNamespace)(type.BaseType));
        if (!baseType) {
            throw new Error(`Type ${type.BaseType} not found, but defined as BaseType of Type ${type.Name}.`);
        }
        return joinTypes(type, joinTypeWithBaseType(baseType, types, joinTypes));
    }
    return type;
}
/**
 * @internal
 */
function parseComplexTypesV4(root) {
    return joinTypesWithBaseTypes((0, edmx_parser_1.parseComplexTypesBase)(root), joinComplexTypes);
}
exports.parseComplexTypesV4 = parseComplexTypesV4;
/**
 * @internal
 */
function parseEnumTypes(root) {
    return (0, edmx_parser_1.getMergedPropertyWithNamespace)(root, 'EnumType').map(edmxEnumType => ({
        Name: edmxEnumType.Name,
        UnderlyingType: edmxEnumType.UnderlyingType,
        Member: (0, generator_utils_1.forceArray)(edmxEnumType.Member),
        Namespace: edmxEnumType.Namespace
    }));
}
exports.parseEnumTypes = parseEnumTypes;
/**
 * @internal
 */
function parseEntityType(root) {
    const entityTypes = (0, edmx_parser_1.parseEntityTypesBase)(root);
    return joinTypesWithBaseTypes(entityTypes, joinEntityTypes);
}
exports.parseEntityType = parseEntityType;
/**
 * @internal
 */
function parseEntitySetsV4(root) {
    return (0, edmx_parser_1.parseEntitySetsBase)(root).map(entitySet => ({
        ...entitySet,
        NavigationPropertyBinding: parseNavigationPropertyBinding(entitySet)
    }));
}
exports.parseEntitySetsV4 = parseEntitySetsV4;
function parseNavigationPropertyBinding(entitySet) {
    return (0, generator_utils_1.forceArray)(entitySet.NavigationPropertyBinding);
}
/**
 * @internal
 */
function parseOperationImports(root, operationType) {
    const operations = (0, edmx_parser_1.getPropertyFromEntityContainer)(root, `${voca_1.default.capitalize(operationType)}Import`);
    return operations.map(operation => ({
        ...operation,
        operationName: operation[voca_1.default.capitalize(operationType)],
        operationType
    }));
}
exports.parseOperationImports = parseOperationImports;
/**
 * @internal
 */
function parseOperations(root) {
    return [
        ...(0, edmx_parser_1.getMergedPropertyWithNamespace)(root, 'Function'),
        ...(0, edmx_parser_1.getMergedPropertyWithNamespace)(root, 'Action')
    ].map(operation => ({
        ...operation,
        Parameter: (0, generator_utils_1.forceArray)(operation.Parameter),
        IsBound: operation.IsBound || 'false'
    }));
}
exports.parseOperations = parseOperations;
//# sourceMappingURL=edmx-parser.js.map