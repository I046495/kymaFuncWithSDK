"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateSourcesForService = exports.generateProject = exports.transpileDirectories = exports.getInstallODataErrorMessage = exports.generate = void 0;
const fs_1 = require("fs");
const path_1 = require("path");
const internal_1 = require("@sap-cloud-sdk/generator-common/internal");
const util_1 = require("@sap-cloud-sdk/util");
const fs_extra_1 = require("fs-extra");
const ts_morph_1 = require("ts-morph");
const file_1 = require("./batch/file");
const file_2 = require("./complex-type/file");
const file_3 = require("./entity/file");
const file_4 = require("./enum-type/file");
const file_generator_1 = require("./file-generator");
const options_1 = require("./options");
const generator_utils_1 = require("./generator-utils");
const generator_without_ts_morph_1 = require("./generator-without-ts-morph");
const file_5 = require("./generator-without-ts-morph/request-builder/file");
const file_6 = require("./generator-without-ts-morph/service/file");
const file_7 = require("./operations/file");
const sdk_metadata_1 = require("./sdk-metadata");
const service_generator_1 = require("./service-generator");
const index_file_1 = require("./service/index-file");
const package_json_1 = require("./service/package-json");
const readme_1 = require("./service/readme");
const { mkdir, readdir } = fs_1.promises;
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'generator'
});
/**
 * Main entry point for the OData client generation.
 * Generates models and API files.
 * @param options - Options to configure generation.
 */
async function generate(options) {
    const parsedOptions = (0, internal_1.parseOptions)(options_1.cliOptions, options);
    if (parsedOptions.verbose) {
        (0, util_1.setLogLevel)('verbose', logger);
    }
    logger.verbose(`Parsed Options: ${JSON.stringify(parsedOptions, null, 2)}`);
    return generateWithParsedOptions(parsedOptions);
}
exports.generate = generate;
/**
 * @internal
 * This is the main entry point for generation, after options were parsed - either from the CLI or from the programmatically passed configuration.
 */
async function generateWithParsedOptions(options) {
    const projectAndServices = await generateProject(options);
    if (!projectAndServices) {
        throw Error('The project is undefined.');
    }
    const { services } = projectAndServices;
    await generateFilesWithoutTsMorph(services, options);
    if (options.transpile) {
        const directories = services
            .filter(async (service) => {
            const files = await readdir((0, path_1.join)(options.outputDir, service.serviceOptions.directoryName));
            return files.includes('tsconfig.json');
        })
            .map(service => (0, path_1.join)(options.outputDir, service.serviceOptions.directoryName));
        const chunks = (0, util_1.splitInChunks)(directories, options.transpilationProcesses);
        try {
            await chunks.reduce((all, chunk) => all.then(() => transpileDirectories(chunk, options)), Promise.resolve());
        }
        catch (err) {
            if (err.message?.includes('error TS2307')) {
                throw new util_1.ErrorWithCause(getInstallODataErrorMessage(projectAndServices), err);
            }
            throw err;
        }
    }
}
/**
 * @internal
 * @param projectAndServices - Generated project with services.
 * @returns An error message with a recommendation to install specific SDK packages.
 */
function getInstallODataErrorMessage(projectAndServices) {
    const hasV2 = projectAndServices.services.some(service => service.oDataVersion === 'v2');
    const hasV4 = projectAndServices.services.some(service => service.oDataVersion === 'v4');
    if (hasV2 && hasV4) {
        return 'Did you forget to install "@sap-cloud-sdk/odata-v2" and "@sap-cloud-sdk/odata-v4"?';
    }
    return `Did you forget to install "@sap-cloud-sdk/odata-v${hasV2 ? '2' : '4'}"?`;
}
exports.getInstallODataErrorMessage = getInstallODataErrorMessage;
/**
 * @internal
 */
async function transpileDirectories(directories, options) {
    return Promise.all(directories.map(async (directory) => {
        const [compilerOptions, createFileOptions] = await Promise.all([
            (0, internal_1.readCompilerOptions)(directory),
            getFileCreationOptions(options)
        ]);
        return (0, internal_1.transpileDirectory)(directory, {
            compilerOptions,
            createFileOptions
        });
    }));
}
exports.transpileDirectories = transpileDirectories;
/**
 * @internal
 */
async function generateProject(options) {
    const services = await parseServices(options);
    if (options.clearOutputDir) {
        (0, fs_extra_1.emptyDirSync)(options.outputDir.toString());
    }
    const project = new ts_morph_1.Project(projectOptions());
    const promises = services.map(service => generateSourcesForService(service, project, options));
    if (options.optionsPerService) {
        logger.verbose('Generating options per service ...');
        const optionsPerService = services.reduce((prev, curr) => {
            const relativePath = (0, internal_1.getRelPathWithPosixSeparator)(curr.edmxPath.toString());
            return { ...prev, [relativePath]: curr.serviceOptions };
        }, {});
        await (0, internal_1.writeOptionsPerService)(options.optionsPerService, optionsPerService, options);
    }
    await Promise.all(promises);
    return { project, services };
}
exports.generateProject = generateProject;
async function generateFilesWithoutTsMorph(services, options) {
    const promises = services.flatMap(service => [
        generateEntityApis(service, options),
        generateServiceFile(service, options),
        generateIncludes(service, options)
    ]);
    await Promise.all(promises);
}
async function getFileCreationOptions(options) {
    return {
        prettierOptions: await (0, internal_1.readPrettierConfig)(options.prettierConfig?.toString()),
        overwrite: options.overwrite
    };
}
async function generateIncludes(service, options) {
    if (options.include && options.include.length > 0) {
        const serviceDir = (0, path_1.join)(options.outputDir, service.serviceOptions.directoryName);
        await (0, internal_1.copyFiles)(options.include, serviceDir, options.overwrite);
    }
}
async function generateServiceFile(service, options) {
    const serviceDir = (0, path_1.join)(options.outputDir, service.serviceOptions.directoryName);
    const createFileOptions = await getFileCreationOptions(options);
    await (0, internal_1.createFile)(serviceDir, 'service.ts', (0, file_6.serviceFile)(service), createFileOptions);
}
async function generateEntityApis(service, options) {
    const createFileOptions = await getFileCreationOptions(options);
    await Promise.all(service.entities.map(entity => (0, internal_1.createFile)((0, path_1.join)(options.outputDir, service.serviceOptions.directoryName), `${entity.className}Api.ts`, (0, generator_without_ts_morph_1.entityApiFile)(entity, service), createFileOptions)));
}
/**
 * @internal
 */
async function generateSourcesForService(service, project, options) {
    const serviceDirPath = (0, path_1.join)(options.outputDir, service.serviceOptions.directoryName);
    const serviceDir = project.createDirectory(serviceDirPath);
    const createFileOptions = await getFileCreationOptions(options);
    if (!(0, fs_1.existsSync)(serviceDirPath)) {
        await mkdir(serviceDirPath, { recursive: true });
    }
    const filePromises = [];
    logger.verbose(`[${service.originalFileName}] Generating entities ...`);
    if (options.packageJson) {
        filePromises.push((0, internal_1.createFile)(serviceDirPath, 'package.json', await (0, package_json_1.packageJson)({
            npmPackageName: service.serviceOptions.packageName,
            sdkVersion: await (0, internal_1.getSdkVersion)(),
            description: (0, internal_1.packageDescription)(service.speakingModuleName),
            oDataVersion: service.oDataVersion
        }), createFileOptions));
    }
    if (options.transpile || options.tsconfig) {
        filePromises.push((0, internal_1.createFile)(serviceDirPath, 'tsconfig.json', options.tsconfig
            ? await (0, internal_1.readCustomTsConfig)(options.tsconfig)
            : (0, internal_1.formatTsConfig)(), createFileOptions));
    }
    if ((0, generator_utils_1.hasEntities)(service)) {
        logger.verbose(`[${service.originalFileName}] Generating batch request builder ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'BatchRequest', (0, file_1.batchSourceFile)(service), createFileOptions));
    }
    service.entities.forEach(entity => {
        logger.verbose(`Generating entity: ${entity.className}...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, entity.className, (0, file_3.entitySourceFile)(entity, service), createFileOptions));
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, `${entity.className}RequestBuilder`, (0, file_5.requestBuilderSourceFile)(entity, service.oDataVersion), createFileOptions));
    });
    service.enumTypes.forEach(enumType => {
        logger.verbose(`[${service.originalFileName}] Generating enum type ${enumType.originalName} ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, enumType.typeName, (0, file_4.enumTypeSourceFile)(enumType), createFileOptions));
    });
    service.complexTypes.forEach(complexType => {
        logger.verbose(`[${service.originalFileName}] Generating complex type ${complexType.originalName} ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, complexType.typeName, (0, file_2.complexTypeSourceFile)(complexType, service.oDataVersion), createFileOptions));
    });
    // Merge generated function-imports.ts and action-imports.ts into one operations.ts.
    if (service.operations.length) {
        logger.verbose(`[${service.originalFileName}] Generating operations ...`);
        filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'operations', (0, file_7.operationsSourceFile)(service), createFileOptions));
    }
    filePromises.push((0, file_generator_1.sourceFile)(serviceDir, 'index', (0, index_file_1.indexFile)(service), createFileOptions));
    if (options.readme) {
        logger.verbose(`[${service.originalFileName}] Generating readme ...`);
        filePromises.push((0, internal_1.createFile)(serviceDirPath, 'README.md', (0, readme_1.readme)(service), createFileOptions));
    }
    if (options.metadata) {
        const { clientFileName } = (0, internal_1.getSdkMetadataFileNames)(service.originalFileName);
        logger.verbose(`Generating sdk client metadata ${clientFileName}...`);
        const path = (0, path_1.resolve)((0, path_1.dirname)(service.edmxPath.toString()), 'sdk-metadata');
        if (!(0, fs_1.existsSync)(path)) {
            await mkdir(path);
        }
        filePromises.push((0, internal_1.createFile)(path, clientFileName, JSON.stringify(await (0, sdk_metadata_1.sdkMetadata)(service), null, 2), createFileOptions));
    }
    await Promise.all(filePromises);
}
exports.generateSourcesForService = generateSourcesForService;
function projectOptions() {
    return {
        skipAddingFilesFromTsConfig: true,
        manipulationSettings: {
            indentationText: ts_morph_1.IndentationText.TwoSpaces,
            insertSpaceAfterOpeningAndBeforeClosingNonemptyBraces: true,
            quoteKind: ts_morph_1.QuoteKind.Single
        },
        compilerOptions: {
            target: ts_morph_1.ScriptTarget.ES2021,
            module: ts_morph_1.ModuleKind.CommonJS,
            declaration: true,
            declarationMap: true,
            sourceMap: true,
            diagnostics: true,
            moduleResolution: ts_morph_1.ModuleResolutionKind.NodeJs,
            esModuleInterop: true,
            inlineSources: false,
            noImplicitAny: true
        }
    };
}
async function parseServices(options) {
    const services = await (0, service_generator_1.parseAllServices)(options);
    if (!services.length) {
        logger.warn('No service definition files found.');
        return [];
    }
    return services;
}
//# sourceMappingURL=generator.js.map