"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.mergeImportDeclarations = exports.enumTypeImportDeclarations = exports.complexTypeImportDeclarations = exports.navPropertyFieldTypeImportNames = exports.propertyFieldTypeImportNames = exports.propertyTypeImportNames = exports.odataImportDeclarationTsMorph = exports.externalImportDeclarationTsMorph = exports.externalImportDeclarationsTsMorph = exports.potentialExternalImportDeclarations = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const ts_morph_1 = require("ts-morph");
const generator_utils_1 = require("./generator-utils");
/**
 * @internal
 */
exports.potentialExternalImportDeclarations = [
    ['moment', 'Moment', 'Duration'],
    ['bignumber.js', 'BigNumber']
];
/**
 * @internal
 */
function externalImportDeclarationsTsMorph(properties) {
    return exports.potentialExternalImportDeclarations
        .map(([moduleSpecifier, ...namedImports]) => externalImportDeclarationTsMorph(properties, moduleSpecifier, namedImports))
        .filter(declaration => declaration.namedImports && declaration.namedImports.length);
}
exports.externalImportDeclarationsTsMorph = externalImportDeclarationsTsMorph;
/**
 * @internal
 */
function externalImportDeclarationTsMorph(properties, moduleSpecifier, namedImports) {
    return {
        kind: ts_morph_1.StructureKind.ImportDeclaration,
        moduleSpecifier,
        namedImports: namedImports.filter(namedImport => properties.map(prop => prop.jsType).includes(namedImport))
    };
}
exports.externalImportDeclarationTsMorph = externalImportDeclarationTsMorph;
/**
 * @internal
 */
function odataImportDeclarationTsMorph(namedImports, odataVersion, internal = false) {
    return {
        kind: ts_morph_1.StructureKind.ImportDeclaration,
        moduleSpecifier: odataVersion === 'v2'
            ? '@sap-cloud-sdk/odata-v2' + (internal ? '/internal' : '')
            : '@sap-cloud-sdk/odata-v4' + (internal ? '/internal' : ''),
        namedImports: (0, util_1.unique)(namedImports)
    };
}
exports.odataImportDeclarationTsMorph = odataImportDeclarationTsMorph;
/**
 * @internal
 */
function propertyTypeImportNames(properties) {
    return properties.map(prop => prop.jsType).includes('Time') ? ['Time'] : [];
}
exports.propertyTypeImportNames = propertyTypeImportNames;
/**
 * @internal
 */
function propertyFieldTypeImportNames(properties) {
    return (0, util_1.unique)(properties
        .filter(prop => !prop.isComplex || prop.isCollection)
        .map(prop => prop.fieldType));
}
exports.propertyFieldTypeImportNames = propertyFieldTypeImportNames;
/**
 * @internal
 */
function navPropertyFieldTypeImportNames(navProperties, oDataVersion) {
    return (0, util_1.unique)(navProperties.map(navProp => (0, generator_utils_1.linkClass)(navProp, oDataVersion)));
}
exports.navPropertyFieldTypeImportNames = navPropertyFieldTypeImportNames;
/**
 * @internal
 */
function complexTypeImportDeclarations(properties) {
    return mergeImportDeclarations(properties
        .filter(prop => prop.isComplex)
        .map(prop => complexTypeImportDeclaration(prop)));
}
exports.complexTypeImportDeclarations = complexTypeImportDeclarations;
/**
 * @internal
 */
function enumTypeImportDeclarations(properties) {
    return mergeImportDeclarations(properties
        .filter(prop => prop.isEnum)
        .map(prop => enumTypeImportDeclaration(prop)));
}
exports.enumTypeImportDeclarations = enumTypeImportDeclarations;
// Only supports named imports
/**
 * @internal
 */
function mergeImportDeclarations(importDeclarations) {
    return importDeclarations
        .reduce((mergedDeclarations, importDeclaration) => {
        const sameModuleSpecifier = mergedDeclarations.find(declaration => declaration.moduleSpecifier === importDeclaration.moduleSpecifier &&
            declaration.isTypeOnly === importDeclaration.isTypeOnly);
        if (sameModuleSpecifier) {
            if (!sameModuleSpecifier.namedImports) {
                sameModuleSpecifier.namedImports = [
                    ...importDeclaration.namedImports
                ];
            }
            else if (sameModuleSpecifier.namedImports instanceof Array) {
                sameModuleSpecifier.namedImports = [
                    ...sameModuleSpecifier.namedImports,
                    ...importDeclaration.namedImports
                ];
            }
            else {
                sameModuleSpecifier.namedImports = [
                    sameModuleSpecifier.namedImports,
                    ...importDeclaration.namedImports
                ];
            }
        }
        else {
            mergedDeclarations.push(importDeclaration);
        }
        return mergedDeclarations;
    }, [])
        .map(importDeclaration => {
        if (!importDeclaration.namedImports) {
            importDeclaration.namedImports = undefined;
        }
        else if (importDeclaration.namedImports instanceof Array) {
            importDeclaration.namedImports = (0, util_1.unique)(importDeclaration.namedImports);
        }
        else {
            importDeclaration.namedImports = [importDeclaration.namedImports];
        }
        return importDeclaration;
    })
        .filter(importDeclaration => importDeclaration.namedImports && importDeclaration.namedImports.length);
}
exports.mergeImportDeclarations = mergeImportDeclarations;
function complexTypeImportDeclaration(prop) {
    return {
        kind: ts_morph_1.StructureKind.ImportDeclaration,
        moduleSpecifier: `./${prop.jsType}`,
        namedImports: [prop.jsType, ...(prop.isCollection ? [] : [prop.fieldType])]
    };
}
function enumTypeImportDeclaration(prop) {
    return {
        kind: ts_morph_1.StructureKind.ImportDeclaration,
        moduleSpecifier: `./${prop.jsType}`,
        namedImports: [prop.jsType]
    };
}
//# sourceMappingURL=imports.js.map