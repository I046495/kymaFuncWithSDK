"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.enumTypeForName = exports.complexTypeFieldForName = exports.complexTypeForName = exports.findEnumType = exports.findComplexType = exports.hasUnsupportedParameterTypes = exports.propertyJsType = exports.typesForCollection = exports.getTypeMappingActionFunction = exports.complexTypeFieldType = exports.checkCollectionKind = exports.isEnumType = exports.isComplexType = exports.isComplexTypeOrEnumType = exports.isV2Metadata = exports.parseCollectionTypeName = exports.parseTypeName = exports.collectionRegExp = exports.complexTypeName = exports.isEdmType = exports.isCollectionType = exports.stripNamespace = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const generator_utils_1 = require("../generator-utils");
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'edmx-to-vdm-util'
});
/**
 * @internal
 */
function stripNamespace(name) {
    const nameParts = name.split('.');
    return nameParts[nameParts.length - 1];
}
exports.stripNamespace = stripNamespace;
/**
 * @internal
 */
function isCollectionType(typeName) {
    return exports.collectionRegExp.test(typeName);
}
exports.isCollectionType = isCollectionType;
/**
 * @internal
 */
function isEdmType(typeName) {
    return typeName.startsWith('Edm');
}
exports.isEdmType = isEdmType;
/**
 * @internal
 */
function complexTypeName(type) {
    return (0, util_1.last)(type.split('.'));
}
exports.complexTypeName = complexTypeName;
/**
 * @internal
 */
exports.collectionRegExp = /Collection\((?<collectionType>.*)\)/;
/**
 * @internal
 */
function parseTypeName(typeName) {
    return isCollectionType(typeName)
        ? parseCollectionTypeName(typeName)
        : typeName;
}
exports.parseTypeName = parseTypeName;
/**
 * @internal
 */
function parseCollectionTypeName(typeName) {
    const name = typeName.match(exports.collectionRegExp)?.groups?.collectionType;
    if (!name) {
        throw new Error(`Cannot parse type name ${typeName}.`);
    }
    return name;
}
exports.parseCollectionTypeName = parseCollectionTypeName;
/**
 * @internal
 */
function isV2Metadata(metadata) {
    return metadata.oDataVersion === 'v2';
}
exports.isV2Metadata = isV2Metadata;
/**
 * @internal
 */
function isComplexTypeOrEnumType(typeName) {
    const typeParts = typeName.split('.');
    return typeParts[0] !== 'Edm' && typeParts[1] !== undefined;
}
exports.isComplexTypeOrEnumType = isComplexTypeOrEnumType;
/**
 * @internal
 */
function isComplexType(name, complexTypes) {
    return isComplexTypeOrEnumType(name)
        ? !!(0, exports.findComplexType)(name, complexTypes)
        : false;
}
exports.isComplexType = isComplexType;
/**
 * @internal
 */
function isEnumType(name, enumTypes) {
    return isComplexTypeOrEnumType(name)
        ? !!(0, exports.findEnumType)(name, enumTypes)
        : false;
}
exports.isEnumType = isEnumType;
/**
 * @internal
 */
function checkCollectionKind(property) {
    if (property.hasOwnProperty('CollectionKind')) {
        logger.warn(`"CollectionKind" attribute found in the "${property.Name}" property. Currently, handling collection of properties is not supported by the generator.`);
    }
}
exports.checkCollectionKind = checkCollectionKind;
/**
 * @internal
 */
function complexTypeFieldType(typeName) {
    return typeName + 'Field';
}
exports.complexTypeFieldType = complexTypeFieldType;
/**
 * @internal
 */
function getTypeMappingActionFunction(typeName) {
    if (isEdmType(typeName)) {
        const edmType = (0, generator_utils_1.getFallbackEdmTypeIfNeeded)(typeName);
        return {
            edmType,
            jsType: (0, generator_utils_1.edmToTsType)(edmType),
            fieldType: (0, generator_utils_1.edmToFieldType)(edmType)
        };
    }
    throw new Error(`Could not get a action/function parameter. '${typeName}' is not an EDM type.`);
}
exports.getTypeMappingActionFunction = getTypeMappingActionFunction;
/**
 * @internal
 */
function typesForCollection(typeName, enumTypes, complexTypes, formattedTypes) {
    const typeInsideCollection = parseCollectionTypeName(typeName);
    if (isEdmType(typeInsideCollection)) {
        const typeEdm = (0, generator_utils_1.getFallbackEdmTypeIfNeeded)(typeInsideCollection);
        return {
            edmType: typeEdm,
            jsType: (0, generator_utils_1.edmToTsType)(typeEdm),
            fieldType: 'CollectionField'
        };
    }
    if (isComplexTypeOrEnumType(typeInsideCollection)) {
        if (isEnumType(typeInsideCollection, enumTypes)) {
            return {
                edmType: 'Edm.Enum',
                jsType: enumTypeForName(typeInsideCollection, enumTypes),
                fieldType: 'CollectionField'
            };
        }
        const typeComplex = complexTypeName(typeInsideCollection) || typeInsideCollection;
        return {
            edmType: typeInsideCollection,
            jsType: complexTypes
                ? complexTypeForName(typeInsideCollection, complexTypes)
                : formattedTypes[typeComplex],
            fieldType: 'CollectionField'
        };
    }
    throw new Error('Types in inside a collection must be either have complex or EDM types.');
}
exports.typesForCollection = typesForCollection;
/**
 * @internal
 */
const propertyJsType = (type) => type.startsWith('Edm.') ? (0, generator_utils_1.edmToTsType)(type) : undefined;
exports.propertyJsType = propertyJsType;
/**
 * @internal
 */
function hasUnsupportedParameterTypes(operation) {
    const unsupportedParameters = operation.Parameter.filter(p => !isEdmType(p.Type));
    if (unsupportedParameters.length) {
        logger.warn([
            `Found unsupported parameter types for function or action '${operation.Name}'.`,
            'The SAP Cloud SDK only supports EDM types in parameters.',
            'Skipping code generation for function/action.',
            `Unsupported parameter types: [${unsupportedParameters
                .map(p => `'${p.Type}'`)
                .join(', ')}].`
        ].join('\n'));
        return true;
    }
    return false;
}
exports.hasUnsupportedParameterTypes = hasUnsupportedParameterTypes;
const getPostfix = (type) => (0, util_1.last)(type.split('.'));
/**
 * @internal
 */
const findComplexType = (name, complexTypes) => complexTypes.find(c => c.originalName === getPostfix(name));
exports.findComplexType = findComplexType;
/**
 * @internal
 */
const findEnumType = (name, enumTypes) => enumTypes.find(e => e.originalName === getPostfix(name));
exports.findEnumType = findEnumType;
/**
 * @internal
 */
function complexTypeForName(name, complexTypes) {
    const complexType = (0, exports.findComplexType)(name, complexTypes);
    if (complexType) {
        return complexType.typeName;
    }
    logger.warn(`No complex type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
exports.complexTypeForName = complexTypeForName;
/**
 * @internal
 */
function complexTypeFieldForName(name, complexTypes) {
    const complexType = (0, exports.findComplexType)(name, complexTypes);
    if (complexType) {
        return complexTypeFieldType(complexType.typeName);
    }
    logger.warn(`No complex type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
exports.complexTypeFieldForName = complexTypeFieldForName;
/**
 * @internal
 */
function enumTypeForName(name, enumTypes) {
    const enumType = (0, exports.findEnumType)(name, enumTypes);
    if (enumType) {
        return enumType.typeName;
    }
    logger.warn(`No enum type mapping found for ${name}! Using "any" instead. This will most likely result in errors.`);
    return 'any';
}
exports.enumTypeForName = enumTypeForName;
//# sourceMappingURL=edmx-to-vdm-util.js.map