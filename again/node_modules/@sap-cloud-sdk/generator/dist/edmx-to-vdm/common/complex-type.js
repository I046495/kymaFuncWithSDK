"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTypeMappingComplexProperties = exports.transformComplexTypesBase = void 0;
const generator_utils_1 = require("../../generator-utils");
const description_util_1 = require("../description-util");
const edmx_to_vdm_util_1 = require("../edmx-to-vdm-util");
const name_formatting_strategies_1 = require("../../name-formatting-strategies");
/**
 * @internal
 */
function transformComplexTypesBase(complexTypes, enumTypes, formatter) {
    const formattedTypes = complexTypes.reduce((formatted, c) => ({
        ...formatted,
        [c.Name]: formatter.originalToComplexTypeName(c.Name)
    }), {});
    return complexTypes.map(c => {
        const typeName = formattedTypes[c.Name];
        return {
            typeName,
            originalName: c.Name,
            fieldType: (0, edmx_to_vdm_util_1.complexTypeFieldType)(typeName),
            properties: c.Property.map(p => {
                (0, edmx_to_vdm_util_1.checkCollectionKind)(p);
                const instancePropertyName = formatter.originalToInstancePropertyName(c.Name, p.Name);
                const isCollection = (0, edmx_to_vdm_util_1.isCollectionType)(p.Type);
                const parsed = isCollection ? (0, edmx_to_vdm_util_1.parseCollectionTypeName)(p.Type) : p.Type;
                const isComplexOrEnum = (0, edmx_to_vdm_util_1.isComplexTypeOrEnumType)(parsed);
                const isEnum = (0, edmx_to_vdm_util_1.isEnumType)(parsed, enumTypes);
                const isComplex = isComplexOrEnum ? !isEnum : false;
                const typeMapping = getTypeMappingComplexProperties(p.Type, enumTypes, formattedTypes, isCollection, isEnum, isComplex);
                return {
                    originalName: p.Name,
                    instancePropertyName,
                    staticPropertyName: formatter.originalToStaticPropertyName(c.Name, p.Name),
                    propertyNameAsParam: (0, name_formatting_strategies_1.applyPrefixOnJsConflictParam)(instancePropertyName),
                    description: (0, description_util_1.propertyDescription)(p),
                    technicalName: p.Name,
                    nullable: (0, generator_utils_1.isNullableProperty)(p),
                    edmType: typeMapping.edmType,
                    jsType: typeMapping.jsType,
                    fieldType: typeMapping.fieldType,
                    isComplex,
                    isEnum,
                    isCollection
                };
            }),
            namespace: c.Namespace
        };
    });
}
exports.transformComplexTypesBase = transformComplexTypesBase;
/**
 * @internal
 */
function getTypeMappingComplexProperties(typeName, enumTypes, formattedTypes, isCollection, isEnum, isComplex) {
    if ((0, edmx_to_vdm_util_1.isEdmType)(typeName)) {
        const edmFallback = (0, generator_utils_1.getFallbackEdmTypeIfNeeded)(typeName);
        return {
            edmType: edmFallback,
            jsType: (0, generator_utils_1.edmToTsType)(edmFallback),
            fieldType: (0, generator_utils_1.edmToComplexPropertyType)(edmFallback)
        };
    }
    if (isCollection) {
        return (0, edmx_to_vdm_util_1.typesForCollection)(typeName, enumTypes, undefined, formattedTypes);
    }
    if (isEnum) {
        return {
            edmType: 'Edm.Enum',
            jsType: (0, edmx_to_vdm_util_1.enumTypeForName)(typeName, enumTypes),
            fieldType: 'EnumField'
        };
    }
    if (isComplex) {
        const withoutPrefix = (0, edmx_to_vdm_util_1.complexTypeName)(typeName);
        return {
            edmType: typeName,
            jsType: formattedTypes[withoutPrefix],
            fieldType: (0, edmx_to_vdm_util_1.complexTypeFieldType)(formattedTypes[withoutPrefix])
        };
    }
    throw new Error(`No types found for ${typeName}`);
}
exports.getTypeMappingComplexProperties = getTypeMappingComplexProperties;
//# sourceMappingURL=complex-type.js.map