"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateEntitiesV4 = void 0;
const edmx_parser_1 = require("../../edmx-parser/v4/edmx-parser");
const entity_1 = require("../common/entity");
const edmx_to_vdm_util_1 = require("../edmx-to-vdm-util");
const operation_1 = require("./operation");
/**
 * @internal
 */
function generateEntitiesV4(serviceMetadata, complexTypes, enumTypes, formatter) {
    const entitySets = (0, edmx_parser_1.parseEntitySetsV4)(serviceMetadata.edmx.root);
    const entityTypes = (0, edmx_parser_1.parseEntityType)(serviceMetadata.edmx.root);
    const entitiesMetadata = (0, entity_1.joinEntityMetadata)(entitySets, entityTypes, serviceMetadata.swagger);
    const classNames = (0, entity_1.createEntityClassNames)(entitiesMetadata, formatter);
    const entities = entitiesMetadata.map(({ entityType, entitySet }) => ({
        entityTypeName: entityType.Name,
        className: classNames[entitySet.Name],
        entityTypeNamespace: entityType.Namespace
    }));
    return entitiesMetadata.map(entityMetadata => ({
        ...(0, entity_1.transformEntityBase)(entityMetadata, classNames, complexTypes, enumTypes, formatter),
        navigationProperties: navigationProperties(entityMetadata.entityType, entityMetadata.entitySet, classNames, formatter),
        operations: (0, operation_1.generateBoundOperations)(serviceMetadata, entityMetadata.entityType.Namespace, entities, complexTypes, formatter, entityMetadata.entitySet.Name, classNames[entityMetadata.entitySet.Name])
    }));
}
exports.generateEntitiesV4 = generateEntitiesV4;
function navigationProperties(entityType, entitySet, classNames, formatter) {
    return entitySet.NavigationPropertyBinding.filter(navBinding => !isDerivedNavBindingPath(navBinding.Path)).map(navBinding => {
        const navProp = entityType.NavigationProperty.find(n => n.Name === navBinding.Path);
        if (!navProp) {
            throw new Error(`Could not find navigation property ${navBinding.Path} in entity type ${entityType.Name}.`);
        }
        const isCollection = (0, edmx_to_vdm_util_1.isCollectionType)(navProp.Type);
        return {
            ...(0, entity_1.navigationPropertyBase)(navProp.Name, entitySet.Name, formatter),
            from: entityType.Name,
            to: navBinding.Target,
            toEntityClassName: classNames[navBinding.Target],
            isCollection
        };
    });
}
// TODO: This should be removed once derived types are considered.
function isDerivedNavBindingPath(path) {
    return path.includes('/');
}
//# sourceMappingURL=entity.js.map