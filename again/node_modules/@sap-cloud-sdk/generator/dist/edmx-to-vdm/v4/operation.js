"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateBoundOperations = exports.generateUnboundOperations = exports.filterAndTransformOperations = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const edmx_parser_1 = require("../../edmx-parser");
const swagger_parser_1 = require("../../swagger-parser/swagger-parser");
const operation_1 = require("../common/operation");
const operation_return_type_1 = require("../common/operation-return-type");
const edmx_to_vdm_util_1 = require("../edmx-to-vdm-util");
const operation_util_1 = require("./operation-util");
const logger = (0, util_1.createLogger)({
    package: 'generator',
    messageContext: 'operation'
});
const extractResponse = (response) => `${response}.value`;
function splitMissingOperation(operationImports, operations) {
    return operationImports.reduce(([withoutOperation, withOperation], curr) => {
        const operation = (0, operation_util_1.findOperationByImportName)(operations, curr.operationName);
        if (operation) {
            withOperation.push({
                Name: curr.Name,
                operationName: curr.operationName,
                Parameter: operation.Parameter,
                ReturnType: operation.ReturnType,
                IsBound: operation.IsBound.toLowerCase() === 'true',
                operationType: curr.operationType
            });
        }
        else {
            withoutOperation.push(curr);
        }
        return [withoutOperation, withOperation];
    }, [[], []]);
}
function extractEntitySetName(type) {
    const components = type.split('.');
    return components.pop();
}
function buildBoundOperation(currentOperation, edmxEntitySetName) {
    return {
        ...currentOperation,
        entitySetName: edmxEntitySetName,
        Parameter: currentOperation.Parameter.slice(1)
    };
}
function splitMissingParameter(operations) {
    return operations.reduce(([validOperations, operationsWithoutRequiredParameters], curr) => {
        if (!curr.IsBound) {
            return [
                [...validOperations, curr],
                operationsWithoutRequiredParameters
            ];
        }
        if (!curr.Parameter.length) {
            return [
                validOperations,
                [...operationsWithoutRequiredParameters, curr]
            ];
        }
        const edmxEntitySetName = extractEntitySetName(curr.Parameter[0].Type);
        if (edmxEntitySetName) {
            return [
                [...validOperations, buildBoundOperation(curr, edmxEntitySetName)],
                operationsWithoutRequiredParameters
            ];
        }
        return [validOperations, [...operationsWithoutRequiredParameters, curr]];
    }, [[], []]);
}
/**
 * @internal
 * Joins the operation and operation Import.
 * Filters out all operations which do not have a OperationImport
 * Filters out all bound operations without a parameter and extracts the entity set name from the first parameter
 * It also removes the first parameter which contains only the entity information
 */
function filterAndTransformOperations(operationImports, operations, isBound) {
    const filteredByBoundOperations = operations.filter(operation => (operation.IsBound.toLowerCase() === 'true') === isBound);
    const [withoutOperation, withOperation] = splitMissingOperation(operationImports, filteredByBoundOperations);
    const [validOperations, operationsWithoutRequiredParameters] = splitMissingParameter(withOperation);
    if (operationsWithoutRequiredParameters.length) {
        logger.warn(`No parameter for bound operation which is needed to find the related entity. Skipping code generation: ${operationsWithoutRequiredParameters
            .map(operation => operation.operationName)
            .join(', \n')}`);
    }
    if (withoutOperation.length) {
        const operationType = withoutOperation[0].operationType;
        logger.warn(`Could not find ${operationType}s referenced by the following ${operationType} imports. Skipping code generation: ${withoutOperation
            .map(operationImport => `${operationImport.Name} => ${operationImport.operationName}`)
            .join(', \n')}`);
    }
    return validOperations;
}
exports.filterAndTransformOperations = filterAndTransformOperations;
/**
 * @internal
 */
function generateUnboundOperations(serviceMetadata, serviceName, entities, complexTypes, formatter) {
    return generateOperations(serviceMetadata, serviceName, entities, complexTypes, formatter);
}
exports.generateUnboundOperations = generateUnboundOperations;
/**
 * @internal
 */
function generateBoundOperations(serviceMetadata, serviceName, entities, complexTypes, formatter, edmxBindingEntitySetName, bindingEntityClassName) {
    return generateOperations(serviceMetadata, serviceName, entities, complexTypes, formatter, edmxBindingEntitySetName, bindingEntityClassName);
}
exports.generateBoundOperations = generateBoundOperations;
/**
 * @internal
 */
function generateOperations(serviceMetadata, serviceName, entities, complexTypes, formatter, edmxBindingEntitySetName, className) {
    const operations = (0, edmx_parser_1.parseOperations)(serviceMetadata.edmx.root);
    const operationImports = [
        ...(0, edmx_parser_1.parseOperationImports)(serviceMetadata.edmx.root, 'function'),
        ...(0, edmx_parser_1.parseOperationImports)(serviceMetadata.edmx.root, 'action')
    ];
    const joinedOperationData = filterAndTransformOperations(operationImports, operations, !!edmxBindingEntitySetName)
        .filter(operation => !edmxBindingEntitySetName ||
        edmxBindingEntitySetName === operation.entitySetName)
        // TODO 1571 remove when supporting entity type as parameter
        .filter(operation => !(0, edmx_to_vdm_util_1.hasUnsupportedParameterTypes)(operation));
    return joinedOperationData.map(operation => {
        const httpMethod = operation.operationType === 'function' ? 'get' : 'post';
        const swaggerDefinition = (0, swagger_parser_1.getSwaggerDefinitionForOperation)(operation.Name, httpMethod, serviceMetadata.swagger);
        return {
            ...(0, operation_1.transformOperationBase)(operation, operation.Parameter, operation.operationType, swaggerDefinition, formatter, edmxBindingEntitySetName),
            httpMethod,
            returnType: (0, operation_return_type_1.parseOperationReturnType)(operation.ReturnType, entities, complexTypes, extractResponse, serviceName, operation.IsBound),
            entityClassName: className
        };
    });
}
//# sourceMappingURL=operation.js.map