"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.joinAssociationMetadata = exports.generateEntitiesV2 = void 0;
const entity_1 = require("../common/entity");
const edmx_parser_1 = require("../../edmx-parser/v2/edmx-parser");
const edmx_to_vdm_util_1 = require("../edmx-to-vdm-util");
/**
 * @internal
 */
function generateEntitiesV2(serviceMetadata, complexTypes, formatter) {
    const entitySets = (0, edmx_parser_1.parseEntitySetsV2)(serviceMetadata.edmx.root);
    const entityTypes = (0, edmx_parser_1.parseEntityTypes)(serviceMetadata.edmx.root);
    const entitiesMetadata = (0, entity_1.joinEntityMetadata)(entitySets, entityTypes, serviceMetadata.swagger);
    const classNames = (0, entity_1.createEntityClassNames)(entitiesMetadata, formatter);
    const associations = joinAssociationMetadata((0, edmx_parser_1.parseAssociationSets)(serviceMetadata.edmx.root), (0, edmx_parser_1.parseAssociation)(serviceMetadata.edmx.root));
    return entitiesMetadata.map(entityMetadata => ({
        ...(0, entity_1.transformEntityBase)(entityMetadata, classNames, complexTypes, [], formatter),
        navigationProperties: navigationProperties(entityMetadata, associations, classNames, formatter),
        operations: []
    }));
}
exports.generateEntitiesV2 = generateEntitiesV2;
function navigationProperties(entity, associations, classNames, formatter) {
    const entityType = entity.entityType;
    return entityType.NavigationProperty.map(navProp => {
        const relationship = navProp.Relationship.split('.').pop();
        const association = associations
            .filter(ass => ass.Name === relationship)
            .pop();
        if (!association) {
            throw Error(`Unable to find the association with the name: ${relationship}`);
        }
        const from = association.Ends.find(end => end.Role === navProp.FromRole);
        const to = association.Ends.find(end => end.Role === navProp.ToRole);
        if (!from) {
            throw Error(`Unable to get the role property of the association ends: ${association.Ends} with the name: ${navProp.FromRole}`);
        }
        if (!to) {
            throw Error(`Unable to get the role property of the association ends: ${association.Ends} with the name: ${navProp.ToRole}`);
        }
        return {
            ...(0, entity_1.navigationPropertyBase)(navProp.Name, entity.entitySet.Name, formatter),
            from: entity.entityType.Name,
            to: to.EntitySet,
            toEntityClassName: classNames[to.EntitySet],
            isCollection: to.Multiplicity.endsWith('*')
        };
    });
}
/**
 * @internal
 */
function joinAssociationMetadata(associationSets, associations) {
    return associationSets.map(assocSet => {
        const matchingAssoc = associations.find(a => a.Name === (0, edmx_to_vdm_util_1.stripNamespace)(assocSet.Association));
        if (!matchingAssoc) {
            throw Error(`Unable to match the association set: ${assocSet.Association} with associations: ${associations}.`);
        }
        const ends = assocSet.End.map(assocSetEnd => ({
            ...assocSetEnd,
            ...matchingAssoc.End.find(end => end.Role === assocSetEnd.Role)
        }));
        return {
            Name: matchingAssoc.Name,
            'sap:creatable': assocSet['sap:creatable'],
            'sap:updatable': assocSet['sap:updatable'],
            'sap:deletable': assocSet['sap:deletable'],
            'sap:content-version': assocSet['sap:content-version'],
            Ends: ends
        };
    });
}
exports.joinAssociationMetadata = joinAssociationMetadata;
//# sourceMappingURL=entity.js.map