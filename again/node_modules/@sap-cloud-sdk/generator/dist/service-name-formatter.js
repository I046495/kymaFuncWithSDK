"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.stripCollection = exports.ServiceNameFormatter = void 0;
const util_1 = require("@sap-cloud-sdk/util");
const voca_1 = __importDefault(require("voca"));
const internal_prefix_1 = require("./internal-prefix");
const name_formatting_strategies_1 = require("./name-formatting-strategies");
const reserved_words_1 = require("./reserved-words");
const logger = (0, util_1.createLogger)('service-name-formatter');
/**
 * @internal
 */
class ServiceNameFormatter {
    static originalToServiceName(name) {
        let formattedName = name.replace(/\.|\//g, '_');
        formattedName = stripAPIUnderscore(formattedName);
        formattedName = stripUnderscoreSrv(formattedName);
        formattedName = voca_1.default.kebabCase(formattedName);
        return formattedName.endsWith('service')
            ? formattedName
            : `${formattedName}-service`;
    }
    constructor(serviceName, options) {
        this.serviceWideNameGenerator = new util_1.UniqueNameGenerator('_', [
            ...reserved_words_1.defaultReservedWords,
            ...reserved_words_1.reservedServiceKeywords
        ]);
        this.parameterNameGenerators = {};
        this.staticPropertyNameGenerators = {};
        this.instancePropertyNameGenerators = {};
        const defaults = {
            skipValidation: false,
            entitySetNames: [],
            complexTypeNames: [],
            functionImportNames: []
        };
        const { skipValidation, entitySetNames, complexTypeNames, functionImportNames } = { ...defaults, ...options };
        this.skipValidation = skipValidation;
        this.serviceName = serviceName;
        // Here we assume that entity sets and complex types cannot have the same original name
        [...entitySetNames, ...complexTypeNames].forEach(entitySetOrComplexTypeName => {
            this.staticPropertyNameGenerators[entitySetOrComplexTypeName] =
                new util_1.UniqueNameGenerator('_', reserved_words_1.defaultReservedWords);
            this.instancePropertyNameGenerators[entitySetOrComplexTypeName] =
                new util_1.UniqueNameGenerator('_', reserved_words_1.defaultReservedWords);
        });
        if (functionImportNames) {
            functionImportNames.forEach(functionImportName => {
                this.parameterNameGenerators[functionImportName] =
                    new util_1.UniqueNameGenerator('_', reserved_words_1.defaultReservedWords);
            });
        }
    }
    originalToStaticPropertyName(originalContainerTypeName, originalPropertyName) {
        const transformedName = (0, util_1.upperCaseSnakeCase)((0, internal_prefix_1.stripPrefix)(originalPropertyName));
        const generator = this.getOrInitGenerator(this.staticPropertyNameGenerators, originalContainerTypeName);
        const uniqueName = generator.generateAndSaveUniqueName(transformedName);
        this.assertNameChange({
            originalContainerTypeName,
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    assertNameChange({ originalContainerTypeName, transformedName, uniqueName }) {
        if (uniqueName !== transformedName) {
            const message = `A naming conflict appears for service ${this.serviceName} in container '${originalContainerTypeName}'. The conflict resolution is: ${transformedName} -> ${uniqueName}.`;
            if (this.skipValidation) {
                logger.warn(message);
            }
            else {
                throw new Error(`${message}
If you are ok with this change execute the generator with the '--skipValidation' option.`);
            }
        }
    }
    originalToInstancePropertyName(originalContainerTypeName, originalPropertyName) {
        const transformedName = (0, util_1.camelCase)((0, internal_prefix_1.stripPrefix)(originalPropertyName));
        const generator = this.getOrInitGenerator(this.instancePropertyNameGenerators, originalContainerTypeName);
        const uniqueName = generator.generateAndSaveUniqueName(transformedName);
        this.assertNameChange({
            originalContainerTypeName: 'action/function operation name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToOperationName(originalName) {
        const transformedName = voca_1.default.camelCase((0, internal_prefix_1.stripPrefix)(originalName));
        const newName = this.serviceWideNameGenerator.generateAndSaveUniqueName(transformedName);
        const uniqueName = (0, name_formatting_strategies_1.applyPrefixOnJsConflictFunctionImports)(newName);
        this.assertNameChange({
            originalContainerTypeName: 'action/function operation name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToBoundOperationName(entityName, functionName) {
        const transformedName = this.originalToInstancePropertyName(entityName, functionName);
        const uniqueName = (0, name_formatting_strategies_1.applyPrefixOnJsConflictFunctionImports)(transformedName);
        this.assertNameChange({
            originalContainerTypeName: 'bound action/function operation name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToComplexTypeName(originalName) {
        return this.originalToServiceWideName(originalName, 'complex type name');
    }
    originalToEnumTypeName(originalName) {
        return this.originalToServiceWideName(originalName, 'enum name');
    }
    originalToNavigationPropertyName(entitySetName, originalPropertyName) {
        const transformedName = voca_1.default.camelCase(originalPropertyName);
        const generator = this.getOrInitGenerator(this.instancePropertyNameGenerators, entitySetName);
        const uniqueName = generator.generateAndSaveUniqueName(transformedName);
        this.assertNameChange({
            originalContainerTypeName: entitySetName,
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToParameterName(originalFunctionImportName, originalParameterName) {
        const transformedName = voca_1.default.camelCase(originalParameterName);
        const generator = this.getOrInitGenerator(this.parameterNameGenerators, originalFunctionImportName);
        const uniqueName = generator.generateAndSaveUniqueName(transformedName);
        this.assertNameChange({
            originalContainerTypeName: 'action/function parameter name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToBoundParameterName(entityName, originalFunctionImportName, originalParameterName) {
        const transformedName = voca_1.default.camelCase(originalParameterName);
        const generator = this.getOrInitGenerator(this.parameterNameGenerators, `${entityName}.${originalFunctionImportName}`);
        const uniqueName = generator.generateAndSaveUniqueName(transformedName);
        this.assertNameChange({
            originalContainerTypeName: 'bound action/function parameter name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToEntityClassName(entitySetName) {
        let transformedName = entitySetName;
        if (transformedName.endsWith('Collection')) {
            transformedName = stripCollection(entitySetName);
        }
        transformedName = stripAUnderscore(voca_1.default.titleCase(transformedName));
        const uniqueName = this.serviceWideNameGenerator.generateAndSaveUniqueNamesWithSuffixes(transformedName, getInterfaceNamesSuffixes(), false)[0];
        this.assertNameChange({
            originalContainerTypeName: 'entity set name',
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    originalToServiceWideName(originalName, originalContainerTypeName) {
        const transformedName = stripAUnderscore(voca_1.default.titleCase(originalName)).replace('_', '');
        const uniqueName = this.serviceWideNameGenerator.generateAndSaveUniqueName(transformedName, false);
        this.assertNameChange({
            originalContainerTypeName,
            transformedName,
            uniqueName
        });
        return uniqueName;
    }
    getOrInitGenerator(generators, name) {
        if (!generators[name]) {
            generators[name] = new util_1.UniqueNameGenerator('_', reserved_words_1.defaultReservedWords);
        }
        return generators[name];
    }
}
exports.ServiceNameFormatter = ServiceNameFormatter;
function stripUnderscoreSrv(name) {
    return name.endsWith('_SRV') ? name.substr(0, name.length - 4) : name;
}
function stripAPIUnderscore(name) {
    return name.startsWith('API_') ? name.substring(4, name.length) : name;
}
/**
 * @internal
 */
function stripCollection(name) {
    return name.endsWith('Collection')
        ? name.substring(0, name.length - 10)
        : name;
}
exports.stripCollection = stripCollection;
function stripAUnderscore(name) {
    return name.startsWith('A_') ? name.substring(2, name.length) : name;
}
function getInterfaceNamesSuffixes() {
    return ['Type'];
}
//# sourceMappingURL=service-name-formatter.js.map