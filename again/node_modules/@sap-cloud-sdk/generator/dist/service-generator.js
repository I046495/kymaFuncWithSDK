"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getServiceName = exports.parseService = exports.parseAllServices = void 0;
const internal_1 = require("@sap-cloud-sdk/generator-common/internal");
const edmx_file_reader_1 = require("./edmx-parser/edmx-file-reader");
const swagger_util_1 = require("./swagger-parser/swagger-util");
const edmx_to_vdm_util_1 = require("./edmx-to-vdm/edmx-to-vdm-util");
const v2_1 = require("./edmx-to-vdm/v2");
const v4_1 = require("./edmx-to-vdm/v4");
const service_base_path_1 = require("./service-base-path");
class ServiceGenerator {
    constructor(options) {
        this.options = options;
    }
    async generateAllServices() {
        return Promise.all(this.options.input.map(serviceSpecPath => this.generateService(serviceSpecPath)));
    }
    async generateService(edmxServiceSpecPath) {
        const optionsPerService = await (0, internal_1.getOptionsPerService)(this.options.input, this.options);
        const serviceOptions = optionsPerService[(0, internal_1.getRelPathWithPosixSeparator)(edmxServiceSpecPath)];
        if (!serviceOptions) {
            throw new Error(`Options per service not found for key ${(0, internal_1.getRelPathWithPosixSeparator)(edmxServiceSpecPath)}. Service options are ${JSON.stringify(optionsPerService, null, 2)}`);
        }
        const serviceMetadata = (0, edmx_file_reader_1.readEdmxAndSwaggerFile)(edmxServiceSpecPath);
        const vdmServicePackageMetaData = this.getServicePackageMetaData(serviceMetadata, serviceOptions.directoryName, edmxServiceSpecPath);
        const vdmServiceEntities = (0, edmx_to_vdm_util_1.isV2Metadata)(serviceMetadata.edmx)
            ? (0, v2_1.getServiceEntitiesV2)(serviceMetadata, vdmServicePackageMetaData.className, this.options.skipValidation)
            : (0, v4_1.getServiceEntitiesV4)(serviceMetadata, vdmServicePackageMetaData.className, this.options.skipValidation);
        return {
            ...vdmServicePackageMetaData,
            ...vdmServiceEntities,
            serviceOptions: {
                ...serviceOptions,
                basePath: (0, service_base_path_1.getBasePath)(serviceMetadata, this.options.skipValidation, serviceOptions)
            }
        };
    }
    getServicePackageMetaData(serviceMetadata, directoryName, edmxServiceSpecPath) {
        return {
            oDataVersion: serviceMetadata.edmx.oDataVersion,
            namespaces: serviceMetadata.edmx.namespaces,
            originalFileName: serviceMetadata.edmx.fileName,
            speakingModuleName: (0, internal_1.directoryToSpeakingModuleName)(directoryName),
            className: (0, internal_1.directoryToServiceName)(directoryName),
            edmxPath: edmxServiceSpecPath,
            apiBusinessHubMetadata: (0, swagger_util_1.apiBusinessHubMetadata)(serviceMetadata.swagger)
        };
    }
}
/**
 * @param options - Generator options
 * @returns the parsed services
 * @internal
 */
async function parseAllServices(options) {
    return new ServiceGenerator(options).generateAllServices();
}
exports.parseAllServices = parseAllServices;
/**
 * @param serviceDefinitionPaths - Path to the service definition
 * @param options - Generator options
 * @param mappings - mappings for VDM service names to desired name
 * @param globalNameFormatter - Instance of global name formatter to be used for the parsing process
 * @returns the parsed service
 * @internal
 */
async function parseService(edmxServiceSpecPath, options) {
    return new ServiceGenerator(options).generateService(edmxServiceSpecPath);
}
exports.parseService = parseService;
/**
 * @internal
 */
function getServiceName(service) {
    return service.namespaces.length === 1
        ? service.namespaces[0]
        : service.originalFileName;
}
exports.getServiceName = getServiceName;
//# sourceMappingURL=service-generator.js.map