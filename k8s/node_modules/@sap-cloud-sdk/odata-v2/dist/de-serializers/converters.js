"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.serializeFromMoment = exports.deserializeToMoment = exports.serializeFromTime = exports.deserializeToTime = void 0;
const moment_1 = __importDefault(require("moment"));
const internal_1 = require("@sap-cloud-sdk/odata-common/internal");
/**
 * @internal
 */
function deserializeToTime(value) {
    const regexResult = internal_1.durationRegexV2.exec(value);
    if (!regexResult) {
        throw new Error(`Failed to parse the value: ${value} to time.`);
    }
    const { hours, minutes, seconds } = regexResult?.groups || {};
    return {
        hours: hours ? parseInt(hours.replace('H', ''), 10) : 0,
        minutes: minutes ? parseInt(minutes.replace('M', ''), 10) : 0,
        seconds: seconds ? parseInt(seconds.replace('S', ''), 10) : 0
    };
}
exports.deserializeToTime = deserializeToTime;
/**
 * @internal
 */
function serializeFromTime(value) {
    return ('PT' +
        leftPad(value.hours, 2) +
        'H' +
        leftPad(value.minutes, 2) +
        'M' +
        leftPad(value.seconds, 2) +
        'S');
}
exports.serializeFromTime = serializeFromTime;
/**
 * @internal
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function deserializeToMoment(edmDateTime) {
    const dateTimeOffsetComponents = /^\/Date\((?<signedticks>-{0,1}\d+)((?<offsetsign>[+-])(?<unsignedoffset>\d{4}))?\)\/$/.exec(edmDateTime)?.groups;
    if (!dateTimeOffsetComponents) {
        throw new Error(`Failed to parse edmDateTime: ${edmDateTime} to moment.`);
    }
    const timestamp = (0, moment_1.default)(parseInt(dateTimeOffsetComponents.signedticks));
    if (dateTimeOffsetComponents.offsetsign &&
        dateTimeOffsetComponents.unsignedoffset) {
        const offsetMultiplier = dateTimeOffsetComponents.offsetsign === '+' ? 1 : -1;
        const offsetInMinutes = parseInt(dateTimeOffsetComponents.unsignedoffset);
        return timestamp.utc().utcOffset(offsetMultiplier * offsetInMinutes);
    }
    return timestamp;
}
exports.deserializeToMoment = deserializeToMoment;
/**
 * @internal
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function serializeFromMoment(momentInstance) {
    const timestamp = momentInstance.unix() * 1000;
    // For some reason isUtc() returns wrong values here, so we use the internal flag directly
    if (momentInstance['_isUTC']) {
        const offset = Math.abs(momentInstance.utcOffset());
        const operator = momentInstance.utcOffset() >= 0 ? '+' : '-';
        return `/Date(${timestamp}${operator}${leftPad(offset, 4)})/`;
    }
    return `/Date(${timestamp})/`;
}
exports.serializeFromMoment = serializeFromMoment;
function leftPad(value, targetLength) {
    const str = value.toString();
    if (str.length >= targetLength) {
        return str;
    }
    return '0'.repeat(targetLength - str.length) + str;
}
//# sourceMappingURL=converters.js.map